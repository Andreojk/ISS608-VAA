{
  "hash": "dfd5150dde60d3ef2dda9cb036fe336d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-Home_Ex02\"\nauthor: \"Andre Ong Jia Kang\"\ndate: \"May 23, 2025\"\ndate-modified: \"last-modified\"\nformat:\n  docx:\n    prefer‐html: true\n    code-fold: true\n    code-summary: \"Code\"\n---\n\n\n\n# Overview\n\nFor Take-home Exercise 2, my group members ([Hendra](https://norhendra-isss608.netlify.app/) and [Jin Yao](https://isss608-blessmebellburve.netlify.app/)) and I have decided to do [Mini-Challenge 1](https://vast-challenge.github.io/2025/MC1.html).\n\nThrough our discussion (and the help of a wheel randomizer), we split the challenge's questions amongst ourselves. Hendra will be doing question 2, Jin Yao will be doing question 1 and I will be doing question 3.\n\n## Scenario + Question 3\n\nMy task in MC1 is to help Silas, a local journalist to create beautiful and informative visualizations of this data and uncover new and interesting information. Below is the question I am tasked to solve.\n\n<span style=\"color:red;\">**3.Use your visualizations to develop a profile of what it means to be a rising star in the music industry.**</span>\n\n\n<span style=\"color:red;\">a.  *Visualize the careers of three artists. Compare and contrast their rise in popularity and influence.*</span>\n\n<span style=\"color:red;\">b.  *Using this characterization, give three predictions of who the next Oceanus Folk stars with be over the next five years.*</span>\n\n## Getting Started\n\nLoading the R packages required.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph, visNetwork, gridExtra, igraph)\n```\n:::\n\n\n\nIn the code below, 'fromJSON' of **jsonlite** package is used to import *MC1_graph.json* file ino R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkg <- fromJSON(\"data/MC1_graph.json\")\n```\n:::\n\n\n\n### Inspecting sturcture\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(kg, max.level = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ directed  : logi TRUE\n $ multigraph: logi TRUE\n $ graph     :List of 2\n $ nodes     :'data.frame':\t17412 obs. of  10 variables:\n $ links     :'data.frame':\t37857 obs. of  4 variables:\n```\n\n\n:::\n:::\n\n\n\n### Extract and Inspect\n\n-   Data cleaning by splitting the nodes and links.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes_tbl <- as_tibble(kg$nodes)\nedges_tb1 <- as_tibble(kg$links)\n```\n:::\n\n\n\n### Initial Data Checks\n\nI will be checking the categories for the Nodes,Edges and their count.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = edges_tb1,\n       aes(y = `Edge Type`)) + geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-5-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = nodes_tbl,\n       aes(y = `Node Type`)) + geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-6-1.png)\n:::\n:::\n\n\n\n### visNetwork plot\n\nI will draw up a simple visNetwork to show the linkages of `Edge Type` == \"MemberOf' to respective Person and MusicalGroup nodes. This is for the initial step for visualization and checking the affliation of each Person to a Group.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Load & index the graph\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes)\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% \n  mutate(idx = row_number()) %>% \n  select(id, idx)\n\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>% rename(to   = idx) %>%\n  filter(!is.na(from), !is.na(to))\n\n# 2. Keep only MemberOf edges and their nodes\nmember_edges    <- edges_idx %>% filter(`Edge Type` == \"MemberOf\")\nmember_node_ids <- unique(c(member_edges$from, member_edges$to))\nmember_nodes    <- nodes_tbl %>% \n  mutate(idx = row_number()) %>% \n  filter(idx %in% member_node_ids)\n\n# 3. Build the visNetwork nodes df using the original idx as id\nnodes_df <- member_nodes %>%\n  transmute(\n    id    = idx,                 # must match edges 'from'/'to'\n    label = name,\n    group = `Node Type`,\n    title = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`)\n  )\n\nnodes_df <- nodes_df %>% arrange(label)\n# 4. Build the edges df using the same idx values\nedges_df <- member_edges %>%\n  transmute(\n    from  = from,                # matches nodes_df$id\n    to    = to,                  # matches nodes_df$id\n    title = `Edge Type`\n  )\n\n# 5. Render the network\nvisNetwork(nodes_df, edges_df, height = \"600px\", width = \"100%\") %>%\n  visNodes(shape = \"dot\", font = list(color = \"black\")) %>%\n  visEdges(arrows = \"to\") %>%\n  visOptions(\n    highlightNearest = list(enabled = TRUE, degree = 1),\n    nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)\n  ) %>%\n  visLegend(useGroups = TRUE, width = 0.1, position = \"right\")\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-7-1.png)\n:::\n:::\n\n\n\n## Data Exploring for Top Artists across all genres\n\nLet's check for the most popular genres in the music industry. I want to find out which genres have the most released songs and also whether their songs have appeared on a top record chart.\n\n::: {.callout-note title=\"Nodes to be used\"}\n• notable (boolean) – whether or not the song has appeared on a top record chart\n\n• notoriety_date (string) – if provided, the year in which the song first appeared on a top record chart\n\n• genre (string) – the song’s genre\n:::\n\n::: panel-tabset\n### Total songs in genres (notoriety_date)\n\n-   Let's find out the top genres with the most notoriety_dates.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gridExtra)\n\n# 1. Load your data\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes)\n\n# 2. Filter to Song nodes and flag notoriety\nsongs <- nodes_tbl %>% \n  filter(`Node Type` == \"Song\") %>%\n  mutate(\n    has_notoriety = !is.na(notoriety_date)\n  )\n\n# 3. Count of songs per genre, broken down by notoriety\ngenre_counts <- songs %>%\n  count(genre, has_notoriety, name = \"Count\") %>%\n  arrange(genre)\n\np1 <- ggplot(genre_counts, aes(x = fct_reorder(genre, Count, .fun = sum), \n                               y = Count, \n                               fill = has_notoriety)) +\n  geom_col() +\n  coord_flip() +\n  scale_fill_manual(\n    name   = \"Has Notoriety Date\",\n    values = c(`TRUE` = \"#1f78b4\", `FALSE` = \"#89aac9\"),\n    labels = c(\"No\", \"Yes\")\n  ) +\n  labs(\n    title = \"Number of Songs by Genre (Notoriety Date Present)\",\n    x     = NULL,\n    y     = \"Song Count\"\n  ) +\n  theme_minimal(base_size = 12)\n\n# 4. Optional: Average popularity per genre (if available)\nhas_pop <- \"popularity\" %in% colnames(songs)\nif (has_pop) {\n  genre_pop <- songs %>%\n    group_by(genre) %>%\n    summarise(AvgPopularity = mean(popularity, na.rm = TRUE),\n              .groups = \"drop\") %>%\n    arrange(desc(AvgPopularity))\n  \n  p2 <- ggplot(genre_pop, aes(x = fct_reorder(genre, AvgPopularity), y = AvgPopularity)) +\n    geom_col(fill = \"tomato\") +\n    coord_flip() +\n    labs(\n      title = \"Average Song Popularity by Genre\",\n      x     = NULL,\n      y     = \"Avg. Popularity\"\n    ) +\n    theme_minimal(base_size = 12)\n  \n  # 5. Display side-by-side\n  grid.arrange(p1, p2, ncol = 2)\n} else {\n  # 5. If no popularity field, just show the stacked count plot\n  print(p1)\n}\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-8-1.png)\n:::\n:::\n\n\n\n### Total songs in genres (notoble)\n\n-   We get a much better representation of the total songs an whether it appeared on the top charts below.\n-   Dream Pop has the most songs while Celtic Folk has the least amount of songs in the dataset throughout the years.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gridExtra)\n\n# 1. Load your data\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes)\n\n# 2. Filter to Song nodes and flag notable\nsongs <- nodes_tbl %>% \n  filter(`Node Type` == \"Song\") %>%\n  mutate(\n    has_notable = (notable == TRUE)\n  )\n\n# 3. Count of songs per genre, broken down by notable\ngenre_counts <- songs %>%\n  count(genre, has_notable, name = \"Count\") %>%\n  arrange(genre)\n\np1 <- ggplot(genre_counts, aes(\n         x = fct_reorder(genre, Count, .fun = sum), \n         y = Count, \n         fill = has_notable\n       )) +\n  geom_col() +\n  coord_flip() +\n  scale_fill_manual(\n    name   = \"Has Notable\",\n    values = c(`TRUE`  = \"#1f78b4\", \n               `FALSE` = \"grey80\"),\n    labels = c(\"No\", \"Yes\")\n  ) +\n  labs(\n    title = \"Number of Songs by Genre (Notable Present)\",\n    x     = NULL,\n    y     = \"Song Count\"\n  ) +\n  theme_minimal(base_size = 12)\n\n# 4. Optional: Average popularity per genre (if available)\nhas_pop <- \"popularity\" %in% colnames(songs)\nif (has_pop) {\n  genre_pop <- songs %>%\n    group_by(genre) %>%\n    summarise(AvgPopularity = mean(popularity, na.rm = TRUE),\n              .groups = \"drop\") %>%\n    arrange(desc(AvgPopularity))\n  \n  p2 <- ggplot(genre_pop, aes(\n           x = fct_reorder(genre, AvgPopularity), \n           y = AvgPopularity\n         )) +\n    geom_col(fill = \"tomato\") +\n    coord_flip() +\n    labs(\n      title = \"Average Song Popularity by Genre\",\n      x     = NULL,\n      y     = \"Avg. Popularity\"\n    ) +\n    theme_minimal(base_size = 12)\n  \n  # 5. Display side-by-side\n  grid.arrange(p1, p2, ncol = 2)\n} else {\n  # 5. If no popularity field, just show the stacked count plot\n  print(p1)\n}\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-9-1.png)\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"Note\"}\nAfter analysis, there are songs that never get a notoriety_date chart but are still marked as notable == True. Thus, it would be better to count the notable songs instead of notoriety_date.\n:::\n\n## Top 15 artists with the most notable songs and if it links to the most popular genres.\n\n-   Let's find out the top 15 artists with the most notable songs in this dataset.\n\n### Top 15 Person by Total of Notable Songs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Load & index the graph\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% \n  mutate(idx = row_number())    # add an index for joining\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\n\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# 2. Identify all Person nodes\nperson_idxs <- which(nodes_tbl$`Node Type` == \"Person\")\n\n# 3. Count songs marked 'notable' per Person\nnotable_tbl <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n         from %in% person_idxs) %>%\n  # join to get each target song's 'notable' flag\n  left_join(\n    nodes_tbl %>% select(idx, notable),\n    by = c(\"to\" = \"idx\")\n  ) %>%\n  # keep only those with notable == TRUE\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableSongs\") %>%\n  arrange(desc(NotableSongs))\n\n# 4. Plot the top 5 Persons by number of notable songs\ntop_n <- 15\nnotable_tbl %>%\n  slice_head(n = top_n) %>%\n  ggplot(aes(x = fct_reorder(Person, NotableSongs), y = NotableSongs)) +\n    geom_col(fill = \"turquoise\") +\n    coord_flip() +\n    labs(\n      title = \"Top 15 Persons by Number of Notable Songs\",\n      x     = NULL,\n      y     = \"Count of Notable Songs\"\n    ) +\n    theme_minimal(base_size = 12)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-10-1.png)\n:::\n:::\n\n\n\n::: {.callout-note title=\"Plot 6 Note\"}\nWith this, I will like to visualize these 15 top performers and their affiliation to each genres just as a preview.\n:::\n\n### Table of Artist and Genres appeared\n\n-   The table below shows the notable songs of the artists into the selected top 10 genres.\n\n-   **Top 10 Genres based on total number of songs:**\n\n    \"Dream Pop\", \"Indie Folk\", \"Synthwave\", \"Doom Metal\", \"Oceanus Folk\", \"Alternative Rock\", \"Southern Gothic Rock\", \"Indie Rock\", \"Americana\", \"Psychedelic Rock\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Compute total notable songs per Person\nnotable_tbl_edit <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from %in% person_idxs) %>%\n  left_join(nodes_tbl %>% select(idx, notable), by = c(\"to\" = \"idx\")) %>%\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableSongs\") %>%\n  arrange(desc(NotableSongs))\n\n# 2. Define the 10 genres of interest\ngenres <- c(\n  \"Dream Pop\", \"Indie Folk\", \"Synthwave\", \"Doom Metal\", \"Oceanus Folk\",\n  \"Alternative Rock\", \"Southern Gothic Rock\", \"Indie Rock\",\n  \"Americana\", \"Psychedelic Rock\"\n)\n\n# 3. Compute notable‐song counts by Person × Genre\ngenre_counts <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from %in% person_idxs) %>%\n  left_join(\n    nodes_tbl %>% \n      filter(`Node Type` == \"Song\", genre %in% genres, notable == TRUE) %>%\n      select(idx, genre),\n    by = c(\"to\" = \"idx\")\n  ) %>%\n  filter(!is.na(genre)) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, genre, name = \"Count\")\n\n# 4. Pivot those genres into columns for all persons\ncomparison <- notable_tbl_edit %>%\n  rename(AllGenres = NotableSongs) %>%\n  left_join(\n    genre_counts %>%\n      pivot_wider(\n        id_cols     = Person,\n        names_from  = genre,\n        values_from = Count,\n        values_fill = 0,\n        names_prefix = \"Notable_\"\n      ),\n    by = \"Person\"\n  ) %>%\n  # fill any missing genre columns with zeros\n  mutate(across(where(is.numeric), ~replace_na(.x, 0))) %>%\n  # reorder: Person, AllGenres, then the Notable_* genres\n  select(Person, AllGenres, starts_with(\"Notable_\"))\n\n# 5. Display as a horizontally scrollable DataTable\nlibrary(DT)\nDT::datatable(\n  comparison,\n  options = list(\n    scrollX = TRUE,\n    pageLength = 10\n  )\n)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-11-1.png)\n:::\n:::\n\n\n\n### Top persons in the top 6 genres based on notarable songs.\n\nI will select the top 6 genres based on the previous plot and filter to the top 5 artists with the most notable songs.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Load & index the graph\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% \n  mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# 2. Identify all Person nodes\nperson_idxs <- which(nodes_tbl$`Node Type` == \"Person\")\n\n# 3. Define your genres of interest\ngenres <- c(\"Dream Pop\", \"Indie Folk\", \"Synthwave\", \"Doom Metal\", \"Oceanus Folk\", \"Southern Gothic Rock\")\n\n# 4. Build a lookup of song‐idx → genre + notable flag, for these genres\ngenre_songs <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre %in% genres) %>%\n  select(idx, genre, notable)\n\n# 5. Count notable songs per Person per genre\nnotable_genre_tbl <- edges_idx %>%\n  filter(\n    `Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n    from %in% person_idxs\n  ) %>%\n  inner_join(genre_songs, by = c(\"to\" = \"idx\")) %>%\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(genre, Person, name = \"NotableSongs\") %>%\n  arrange(genre, desc(NotableSongs))\n\n# 6. Take top 5 Persons in each genre\ntop5_by_genre <- notable_genre_tbl %>%\n  group_by(genre) %>%\n  slice_max(NotableSongs, n = 5, with_ties = FALSE) %>%\n  ungroup()\n\n# 7. Plot small multiples\nggplot(top5_by_genre, \n       aes(x = fct_reorder(Person, NotableSongs), y = NotableSongs)) +\n  geom_col(fill = \"darkgreen\") +\n  coord_flip() +\n  facet_wrap(~ genre, scales = \"free_y\", ncol = 2) +\n  labs(\n    title = \"Top 5 Persons by Number of Notable Songs in select 6 most popular Genres\",\n    x     = NULL,\n    y     = \"Count of Notable Songs\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(strip.text = element_text(face = \"bold\"))\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-12-1.png)\n:::\n:::\n\n\n\n::: {.callout-note title=\"Selection\"}\nBased on the charts shown, I will choose the following artist based on high number of notable songs and popular genre. I will also explore and derive some findings of the 3 artists and any characteristics on how **popular** & **influential** they are as top artist in their field.\n\n**1. Kimberly Snyder**\n\n**2. Leyla Graf-Gotthard**\n\n**3. Szymon Pyć**\n:::\n\n# Question 3 Part (a)\n\n<span style=\"color:red;\">Part (a): Visualize the careers of three artists. Compare and contrast their rise in popularity and influence</span>\n\nI have picked the following three artists and genres based on the data exploring conducted:\n\n*1. Kimberly Snyder - Dream Pop*\n\n*2. Leyla Graf-Gotthard - Doom Metal*\n\n*3. Szymon Pyć - Southern Gothic Rock*\n\nI will build a tiny visNetwork graph showing their releases and collaborations over time to check on their popularity and influence.\n\n## Popularity: Comparison Overall vs in Genre by Notable Songs\n\nUsing notable songs as a proxy for popularity, let's compare the total notable songs of the selected 3 artists in their respective genre vs overall.\n\nThis will show how many notable songs the artist produced were actually their main genre.\n\n::: panel-tabset\n### Kimberly Snyder\n\n-   Based on the bar graphs, Kimberly Snyder has the most notable songs released but ties with Matthew Hancock in the Dream Pop genre. However, this also shows that Kimberly has influence on other genres.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gridExtra)\n\n# 1. Load & index the graph\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map    <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\nperson_idxs <- which(nodes_tbl$`Node Type` == \"Person\")\n\n# 2. Dream Pop: top 5 Persons by notable Dream Pop songs\ndp_song_idxs <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Dream Pop\") %>%\n  pull(idx)\n\nnotable_dp_tbl <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from %in% person_idxs, to %in% dp_song_idxs) %>%\n  left_join(nodes_tbl %>% select(idx, notable), by = c(\"to\" = \"idx\")) %>%\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableDreamPopSongs\") %>%\n  arrange(desc(NotableDreamPopSongs))\n\np1 <- notable_dp_tbl %>%\n  slice_head(n = 5) %>%\n  ggplot(aes(x = fct_reorder(Person, NotableDreamPopSongs), \n             y = NotableDreamPopSongs)) +\n    geom_col(fill = \"lightblue\") +\n    coord_flip() +\n    labs(\n      title = \"Top 5 Persons by Notable Dream Pop Songs\",\n      x     = NULL,\n      y     = \"Count of Notable Dream Pop Songs\"\n    ) +\n    theme_minimal(base_size = 10)+\n    theme(\n      plot.title   = element_text(size = 10),\n      plot.subtitle= element_text(size = 8),\n      axis.title.x = element_text(size = 8),\n      axis.text    = element_text(size = 7)\n    )\n\n# 3. Selected Persons: overall notable songs\nfocus_people <- c(\"Kimberly Snyder\", \"Matthew Hancock\", \n                  \"Catherine Clay\", \"Navya Sastry\", \"Kashvi Dhillon\")\n\nnotable_tbl <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from %in% person_idxs) %>%\n  left_join(nodes_tbl %>% select(idx, notable), by = c(\"to\" = \"idx\")) %>%\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableSongs\") %>%\n  arrange(desc(NotableSongs))\n\nplot_tbl <- tibble(Person = focus_people) %>%\n  left_join(notable_tbl, by = \"Person\") %>%\n  replace_na(list(NotableSongs = 0))\n\np2 <- plot_tbl %>%\n  ggplot(aes(x = fct_reorder(Person, NotableSongs), y = NotableSongs)) +\n    geom_col(fill = \"pink\") +\n    coord_flip() +\n    labs(\n      title    = \"Notable Songs by Selected Persons\",\n      x        = NULL,\n      y        = \"Count of Notable Songs\"\n    ) +\n    theme_minimal(base_size = 10)+\n    theme(\n      plot.title   = element_text(size = 10),\n      plot.subtitle= element_text(size = 8),\n      axis.title.x = element_text(size = 8),\n      axis.text    = element_text(size = 7)\n    )\n\n# 4. Arrange side‐by‐side\ngrid.arrange(p1, p2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-13-1.png)\n:::\n:::\n\n\n\n### Leyla Graf-Gotthard\n\n-   Leyla Graf-Gotthard is the top in her genre with some influence in other genres too based on overall.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2. Dream Pop: top 5 Persons by notable Doom Metal songs\ndp_song_idxs2 <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Doom Metal\") %>%\n  pull(idx)\n\nnotable_dp_tbl2 <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from %in% person_idxs, to %in% dp_song_idxs2) %>%\n  left_join(nodes_tbl %>% select(idx, notable), by = c(\"to\" = \"idx\")) %>%\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableDoomMetalSongs\") %>%\n  arrange(desc(NotableDoomMetalSongs))\n\np3 <- notable_dp_tbl2 %>%\n  slice_head(n = 5) %>%\n  ggplot(aes(x = fct_reorder(Person, NotableDoomMetalSongs), \n             y = NotableDoomMetalSongs)) +\n    geom_col(fill = \"lightblue\") +\n    coord_flip() +\n    labs(\n      title = \"Top 5 Persons by Doom Metal Pop Songs\",\n      x     = NULL,\n      y     = \"Count of Notable Doom Metal Songs\"\n    ) +\n    theme_minimal(base_size = 10)+\n    theme(\n      plot.title   = element_text(size = 10),\n      plot.subtitle= element_text(size = 8),\n      axis.title.x = element_text(size = 8),\n      axis.text    = element_text(size = 7)\n    )\n\n# 3. Selected Persons: overall notable songs\nfocus_people2 <- c(\"Leyla Graf-Gotthard\", \"Sandro Gröttner\", \n                  \"Bernfried Stolze\", \"Belinda Knappe\", \"Alla Lorch\")\n\nnotable_tbl2 <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from %in% person_idxs) %>%\n  left_join(nodes_tbl %>% select(idx, notable), by = c(\"to\" = \"idx\")) %>%\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableSongs\") %>%\n  arrange(desc(NotableSongs))\n\nplot_tbl2 <- tibble(Person = focus_people2) %>%\n  left_join(notable_tbl2, by = \"Person\") %>%\n  replace_na(list(NotableSongs = 0))\n\np4 <- plot_tbl2 %>%\n  ggplot(aes(x = fct_reorder(Person, NotableSongs), y = NotableSongs)) +\n    geom_col(fill = \"pink\") +\n    coord_flip() +\n    labs(\n      title    = \"Notable Songs by Selected Persons\",\n      x        = NULL,\n      y        = \"Count of Notable Songs\"\n    ) +\n    theme_minimal(base_size = 10)+\n    theme(\n      plot.title   = element_text(size = 10),\n      plot.subtitle= element_text(size = 8),\n      axis.title.x = element_text(size = 8),\n      axis.text    = element_text(size = 7)\n    )\n\n# 4. Arrange side‐by‐side\ngrid.arrange(p3, p4, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-14-1.png)\n:::\n:::\n\n\n\n### Szymon Pyć\n\n-   Similarly, Szymon is the top in his genre with some influence in other genres too based on overall. He has the most number of notable songs overall.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2. Dream Pop: top 5 Persons by notable Dream Pop songs\ndp_song_idxs3 <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Southern Gothic Rock\") %>%\n  pull(idx)\n\nnotable_dp_tbl3 <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from %in% person_idxs, to %in% dp_song_idxs3) %>%\n  left_join(nodes_tbl %>% select(idx, notable), by = c(\"to\" = \"idx\")) %>%\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableSouthernGothicRockSongs\") %>%\n  arrange(desc(NotableSouthernGothicRockSongs))\n\np5 <- notable_dp_tbl3 %>%\n  slice_head(n = 5) %>%\n  ggplot(aes(x = fct_reorder(Person, NotableSouthernGothicRockSongs), \n             y = NotableSouthernGothicRockSongs)) +\n    geom_col(fill = \"lightblue\") +\n    coord_flip() +\n    labs(\n      title = \"Top 5 Persons by Southern Gothic Rock Songs\",\n      x     = NULL,\n      y     = \"Count of Notable Southern Gothic Rock Songs\"\n    ) +\n    theme_minimal(base_size = 10)+\n    theme(\n      plot.title   = element_text(size = 10),\n      plot.subtitle= element_text(size = 8),\n      axis.title.x = element_text(size = 8),\n      axis.text    = element_text(size = 7)\n    )\n\n# 3. Selected Persons: overall notable songs\nfocus_people3 <- c(\"Szymon Pyć\", \"Urszula Stochmal\",\"Andrew Williams\",\"Jay Walters\",\"Deborah Lucas\")\n\nnotable_tbl3 <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from %in% person_idxs) %>%\n  left_join(nodes_tbl %>% select(idx, notable), by = c(\"to\" = \"idx\")) %>%\n  filter(notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableSongs\") %>%\n  arrange(desc(NotableSongs))\n\nplot_tbl3 <- tibble(Person = focus_people3) %>%\n  left_join(notable_tbl2, by = \"Person\") %>%\n  replace_na(list(NotableSongs = 0))\n\np6 <- plot_tbl3 %>%\n  ggplot(aes(x = fct_reorder(Person, NotableSongs), y = NotableSongs)) +\n    geom_col(fill = \"pink\") +\n    coord_flip() +\n    labs(\n      title    = \"Notable Songs by Selected Persons\",\n      x        = NULL,\n      y        = \"Count of Notable Songs\"\n    ) +\n    theme_minimal(base_size = 10)+\n    theme(\n      plot.title   = element_text(size = 10),\n      plot.subtitle= element_text(size = 8),\n      axis.title.x = element_text(size = 8),\n      axis.text    = element_text(size = 7)\n    )\n\n# 4. Arrange side‐by‐side\ngrid.arrange(p5, p6, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-15-1.png)\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"Notable Songs by Top 5 persons in Genre vs Overall\"}\n-   Based on the notable songs, the selected 3 artists are the top for their genre with influences in other genres as well. This shows the popularity based on using \"Notable Songs\" as a proxy.\n:::\n\n## Popularity: Notable and Notoriety_Date plotted against release_date\n\nLet's take a look at the timeline of notable songs for the 3 artists. I will be using notable, release_date and notoriety_date for the respective plots.\n\nThis will give a broad “popularity over time” view of an artist's impact.\n\n::: {.callout-note title=\"Note on Nodes used\"}\nBelow is some explanation on the nodes used for the plots.\n\n-   Notable: “this song was popular/critically acclaimed,” regardless of whether we know its exact chart date.\n\n-   Notoriety_date: only exists for the subset of notable tracks that actually landed on the charts. It will just be a marker for precised chart‐entry timing information (not the whole thing) as it will always under-count the popularity signal.\n:::\n\n::: panel-tabset\n### Kimberly Snyder\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Load & index the graph\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\n# 2. Build edge index\nid_map    <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>% rename(to   = idx) %>%\n  filter(!is.na(from), !is.na(to))\n\n# 3. Pull Kimberly Snyder’s song edges\nkim_idx <- which(nodes_tbl$name == \"Kimberly Snyder\")\nkim_songs <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"), from == kim_idx) %>%\n  left_join(\n    nodes_tbl %>% select(idx, notable, release_date, notoriety_date),\n    by = c(\"to\" = \"idx\")\n  )\n\n# 4. Extract years\nkim_songs <- kim_songs %>%\n  mutate(\n    release_year   = str_extract(release_date,    \"\\\\d{4}\") %>% as.integer(),\n    notoriety_year = str_extract(notoriety_date, \"\\\\d{4}\") %>% as.integer()\n  )\n\n# 5. Aggregate counts\nnotable_yearly <- kim_songs %>%\n  filter(notable == TRUE, !is.na(release_year)) %>%\n  count(Year = release_year, name = \"Notable\") \n\ncharted_yearly <- kim_songs %>%\n  filter(!is.na(notoriety_year)) %>%\n  count(Year = notoriety_year, name = \"Charted\")\n\ncombined <- full_join(notable_yearly, charted_yearly, by = \"Year\") %>%\n  replace_na(list(Notable = 0, Charted = 0)) %>%\n  arrange(Year)\n\n# 6. Plot both metrics\nggplot(combined, aes(x = Year)) +\n  geom_col(aes(y = Notable, fill = \"Notable\"), alpha = 0.5, width = 0.8) +\n  geom_line(aes(y = Charted, color = \"Charted\"), size = 1) +\n  geom_point(aes(y = Charted, color = \"Charted\"), size = 2) +\n  scale_fill_manual(\n    name   = NULL,\n    values = c(Notable = \"#1f78b4\")\n  ) +\n  scale_color_manual(\n    name   = NULL,\n    values = c(Charted = \"#e31a1c\")\n  ) +\n  labs(\n    title    = \"Kimberly Snyder: Notable vs. Charted Songs by Year\",\n    subtitle = \"Bars = all Notable; Line = those with a known notoriety_date\",\n    x        = \"Year\",\n    y        = \"Song Count\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title    = element_text(size = 14),\n    plot.subtitle = element_text(size = 10),\n    axis.text     = element_text(size = 9),\n    axis.title    = element_text(size = 10)\n  )\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-16-1.png)\n:::\n:::\n\n\n\n### Leyla Graf-Gotthard\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3. Pull Kimberly Snyder’s song edges\nleyla_idx <- which(nodes_tbl$name == \"Leyla Graf-Gotthard\")\nleyla_songs <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"), from == leyla_idx) %>%\n  left_join(\n    nodes_tbl %>% select(idx, notable, release_date, notoriety_date),\n    by = c(\"to\" = \"idx\")\n  )\n\n# 4. Extract years\nleyla_songs <- leyla_songs %>%\n  mutate(\n    release_year   = str_extract(release_date,    \"\\\\d{4}\") %>% as.integer(),\n    notoriety_year = str_extract(notoriety_date, \"\\\\d{4}\") %>% as.integer()\n  )\n\n# 5. Aggregate counts\nnotable_yearly2 <- leyla_songs %>%\n  filter(notable == TRUE, !is.na(release_year)) %>%\n  count(Year = release_year, name = \"Notable\") \n\ncharted_yearly2 <- leyla_songs %>%\n  filter(!is.na(notoriety_year)) %>%\n  count(Year = notoriety_year, name = \"Charted\")\n\ncombined2 <- full_join(notable_yearly2, charted_yearly2, by = \"Year\") %>%\n  replace_na(list(Notable = 0, Charted = 0)) %>%\n  arrange(Year)\n\n# 6. Plot both metrics\nggplot(combined2, aes(x = Year)) +\n  geom_col(aes(y = Notable, fill = \"Notable\"), alpha = 0.5, width = 0.8) +\n  geom_line(aes(y = Charted, color = \"Charted\"), size = 1) +\n  geom_point(aes(y = Charted, color = \"Charted\"), size = 2) +\n  scale_fill_manual(\n    name   = NULL,\n    values = c(Notable = \"#1f78b4\")\n  ) +\n  scale_color_manual(\n    name   = NULL,\n    values = c(Charted = \"#e31a1c\")\n  ) +\n  labs(\n    title    = \"Leyla Graf-Gotthard: Notable vs. Charted Songs by Year\",\n    subtitle = \"Bars = all Notable; Line = those with a known notoriety_date\",\n    x        = \"Year\",\n    y        = \"Song Count\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title    = element_text(size = 14),\n    plot.subtitle = element_text(size = 10),\n    axis.text     = element_text(size = 9),\n    axis.title    = element_text(size = 10)\n  )\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-17-1.png)\n:::\n:::\n\n\n\n### Szymon Pyć\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3. Pull Kimberly Snyder’s song edges\nszymon_idx <- which(nodes_tbl$name == \"Szymon Pyć\")\nszymon_songs <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"), from == szymon_idx) %>%\n  left_join(\n    nodes_tbl %>% select(idx, notable, release_date, notoriety_date),\n    by = c(\"to\" = \"idx\")\n  )\n\n# 4. Extract years\nszymon_songs <- szymon_songs %>%\n  mutate(\n    release_year   = str_extract(release_date,    \"\\\\d{4}\") %>% as.integer(),\n    notoriety_year = str_extract(notoriety_date, \"\\\\d{4}\") %>% as.integer()\n  )\n\n# 5. Aggregate counts\nnotable_yearly3 <- szymon_songs %>%\n  filter(notable == TRUE, !is.na(release_year)) %>%\n  count(Year = release_year, name = \"Notable\") \n\ncharted_yearly3 <- szymon_songs %>%\n  filter(!is.na(notoriety_year)) %>%\n  count(Year = notoriety_year, name = \"Charted\")\n\ncombined3 <- full_join(notable_yearly3, charted_yearly3, by = \"Year\") %>%\n  replace_na(list(Notable = 0, Charted = 0)) %>%\n  arrange(Year)\n\n# 6. Plot both metrics\nggplot(combined3, aes(x = Year)) +\n  geom_col(aes(y = Notable, fill = \"Notable\"), alpha = 0.5, width = 0.8) +\n  geom_line(aes(y = Charted, color = \"Charted\"), size = 1) +\n  geom_point(aes(y = Charted, color = \"Charted\"), size = 2) +\n  scale_fill_manual(\n    name   = NULL,\n    values = c(Notable = \"#1f78b4\")\n  ) +\n  scale_color_manual(\n    name   = NULL,\n    values = c(Charted = \"#e31a1c\")\n  ) +\n  labs(\n    title    = \"Szymon Pyć: Notable vs. Charted Songs by Year\",\n    subtitle = \"Bars = all Notable; Line = those with a known notoriety_date\",\n    x        = \"Year\",\n    y        = \"Song Count\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title    = element_text(size = 14),\n    plot.subtitle = element_text(size = 10),\n    axis.text     = element_text(size = 9),\n    axis.title    = element_text(size = 10)\n  )\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-18-1.png)\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"Notable Songs and Charted Songs across the Years\"}\n-   We can see how each of the artist is able to \"maintain popularity\" be due to their consistent release of \"notable\" songs throughout the years. This is a clear signal on how the artists still maintain their popularity.\n:::\n\n## Popularity: Percentage of un-charted songs released by artist\n\nWe have seen the timeline and number of notable songs. Let's find out how many songs did not chart for each of the artist.\n\n::: panel-tabset\n### Kimberly's songs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Load & index the graph\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\n# 2. Build an edge index\nid_map    <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>% rename(to   = idx) %>%\n  filter(!is.na(from), !is.na(to))\n\n# 3. Find Kimberly Snyder’s index\nkim_idx <- which(nodes_tbl$name == \"Kimberly Snyder\")\n\n# 4. Pull her ComposerOf/PerformerOf song edges, join the Song nodes\nkim_songs <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from == kim_idx) %>%\n  left_join(\n    nodes_tbl %>% \n      filter(`Node Type` == \"Song\") %>% \n      select(idx, notable),\n    by = c(\"to\" = \"idx\")\n  )\n\n# 5. Count notable vs non-notable\nsummary_tbl <- kim_songs %>%\n  mutate(Notable = if_else(notable, \"Yes\", \"No\")) %>%\n  count(Notable) %>%\n  arrange(Notable)\n\n# 6. Plot as a bar chart\n# 6. Plot as a pie chart with labels\nsummary_tbl <- summary_tbl %>%\n  mutate(percentage = round(n / sum(n) * 100, 1),\n         label = paste0(Notable, \"\\n\", n, \" (\", percentage, \"%)\"))\n\nggplot(summary_tbl, aes(x = \"\", y = n, fill = Notable)) +\n  geom_bar(stat = \"identity\", width = 1) +\n  coord_polar(\"y\", start = 0) +\n  scale_fill_manual(values = c(Yes = \"#33a02c\", No = \"#ff7f00\")) +\n  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 3) +\n  labs(\n    title = \"Kimberly Snyder: Notable vs. Non-Notable Songs\",\n    x     = NULL,\n    y     = NULL\n  ) +\n  theme_minimal(base_size = 16) +\n  theme(axis.text.x = element_blank(), \n        axis.ticks = element_blank(), \n        panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-19-1.png)\n:::\n:::\n\n\n\n### Leyla's songs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3. Find Kimberly Snyder’s index\nleyla_idx <- which(nodes_tbl$name == \"Leyla Graf-Gotthard\")\n\n# 4. Pull her ComposerOf/PerformerOf song edges, join the Song nodes\nleyla_songs <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from == leyla_idx) %>%\n  left_join(\n    nodes_tbl %>% \n      filter(`Node Type` == \"Song\") %>% \n      select(idx, notable),\n    by = c(\"to\" = \"idx\")\n  )\n\n# 5. Count notable vs non-notable\nsummary_tbl2 <- leyla_songs %>%\n  mutate(Notable = if_else(notable, \"Yes\", \"No\")) %>%\n  count(Notable) %>%\n  arrange(Notable)\n\n# 6. Plot as a bar chart\n# 6. Plot as a pie chart with labels\nsummary_tbl2 <- summary_tbl2 %>%\n  mutate(percentage = round(n / sum(n) * 100, 1),\n         label = paste0(Notable, \"\\n\", n, \" (\", percentage, \"%)\"))\n\nggplot(summary_tbl2, aes(x = \"\", y = n, fill = Notable)) +\n  geom_bar(stat = \"identity\", width = 1) +\n  coord_polar(\"y\", start = 0) +\n  scale_fill_manual(values = c(Yes = \"#33a02c\", No = \"#ff7f00\")) +\n  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 2.6) +\n  labs(\n    title = \"Leyla Graf-Gotthard: Notable vs. Non-Notable Songs\",\n    x     = NULL,\n    y     = NULL\n  ) +\n  theme_minimal(base_size = 16) +\n  theme(axis.text.x = element_blank(), \n        axis.ticks = element_blank(), \n        panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-20-1.png)\n:::\n:::\n\n\n\n### Szymon's songs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3. Find Kimberly Snyder’s index\nszymon_idx <- which(nodes_tbl$name == \"Szymon Pyć\")\n\n# 4. Pull her ComposerOf/PerformerOf song edges, join the Song nodes\nszymon_songs <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\"),\n         from == szymon_idx) %>%\n  left_join(\n    nodes_tbl %>% \n      filter(`Node Type` == \"Song\") %>% \n      select(idx, notable),\n    by = c(\"to\" = \"idx\")\n  )\n\n# 5. Count notable vs non-notable\nsummary_tbl3 <- szymon_songs %>%\n  mutate(Notable = if_else(notable, \"Yes\", \"No\")) %>%\n  count(Notable) %>%\n  arrange(Notable)\n\n# 6. Plot as a bar chart\n# 6. Plot as a pie chart with labels\nsummary_tbl3 <- summary_tbl3 %>%\n  mutate(percentage = round(n / sum(n) * 100, 1),\n         label = paste0(Notable, \"\\n\", n, \" (\", percentage, \"%)\"))\n\nggplot(summary_tbl3, aes(x = \"\", y = n, fill = Notable)) +\n  geom_bar(stat = \"identity\", width = 1) +\n  coord_polar(\"y\", start = 0) +\n  scale_fill_manual(values = c(Yes = \"#33a02c\", No = \"#ff7f00\")) +\n  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 3) +\n  labs(\n    title = \"Szymon Pyć: Notable vs. Non-Notable Songs\",\n    x     = NULL,\n    y     = NULL\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(axis.text.x = element_blank(), \n        axis.ticks = element_blank(), \n        panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-21-1.png)\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"Notable Songs vs Non-Notable Songs\"}\nThese 3 artist have a majority (more than 2/3) of notable songs as compared to non-notable songs they produced. This is another good signal that shows how the artist is able to maintain popularity by releasing top charting songs consistently.\n:::\n\n## Influence: Work Interactions\n\n-   I want to find out the direct influences by the 3 artist. I will visualise using a visNetwork and count number of **work-type influence edges** each artists has.\n\n::: {.callout-note title=\"Work-type Influences used in plots\"}\nBelow are the definition of the Edge Types being used.\n\n1.  \"MemberOf\" - Indicates that the source node (Person) is (or was) a member of the destination node (MusicalGroup)\n2.  \"ComposerOf\" - Indicates that the source node (Person) composed the destination node (Song or Album)\n3.  \"PerformerOf\" - Indicates a that the source node (Person or MusicalGroup) performed the destination node (Song or Album)\n4.  \"LyricistOf\" - Indicates that the source node (Person) wrote lyrics for the destination node (Song or Album)\n5.  \"RecordedBy\" - Indicates that the destination node (RecordLabel) aided in the recording process for the source node (Song or Album)\n6.  \"ProducerOf\" - Indicates that the source node (Person or RecordLabel) participated in the production of the destination node’s work (Song, Album, Person, or MusicalGroup)\n7.  \"DistributedBy\" - Indicates that the destination node (RecordLabel) aided in the distribution process for the source node (Song or Album)\n:::\n\n### Kimberly Snyder\n\n::: panel-tabset\n#### Work Influence Edge Types\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1.\nid_map <- nodes_tbl %>% \n  mutate(index = row_number()) %>% \n  select(id, index)\n\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>% rename(from = index) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>% rename(to   = index) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# 2. Filter for your chosen edge types & artist\nartists    <- c(\"Kimberly Snyder\")\nedge_types <- c(\"MemberOf\", \"ComposerOf\", \"PerformerOf\",\"LyricistOf\", \"RecordedBy\",\"ProducerOf\",\"DistributedBy\")\ncareer_edges <- edges_idx %>%\n  filter(`Edge Type` %in% edge_types,\n         (from %in% which(nodes_tbl$name %in% artists)) |\n         (to   %in% which(nodes_tbl$name %in% artists)))\n\n# 3. Prune to only the nodes in those edges\ncareer_node_ids <- unique(c(career_edges$from, career_edges$to))\ncareer_nodes    <- nodes_tbl %>% slice(career_node_ids)\n\n# 4. Build visNetwork node DF\nvn_nodes <- career_nodes %>%\n  mutate(\n    id    = row_number(),\n    label = name,\n    group = `Node Type`,\n    title = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`)\n  )\n\n# 5. Build visNetwork edge DF with both label & title\nid_lu <- tibble(old = career_node_ids, new = vn_nodes$id)\nvn_edges <- career_edges %>%\n  inner_join(id_lu, by = c(\"from\" = \"old\")) %>% select(-from)  %>% rename(from = new) %>%\n  inner_join(id_lu, by = c(\"to\"   = \"old\")) %>% select(-to)    %>% rename(to   = new) %>%\n  transmute(\n    from,\n    to,\n    label = `Edge Type`,   # drawn on the arrow\n    title = `Edge Type`,    # hover‐tooltip\n    color = case_when(\n      label == \"MemberOf\"   ~ \"#e31a1c\",\n      label == \"ComposerOf\" ~ \"#33a02c\",\n      label == \"PerformerOf\"~ \"#1f78b4\",\n      label == \"LyricistOf\" ~ \"#ff7f00\",\n      label == \"RecordedBy\" ~ \"#6a329f\",\n      label == \"ProducerOf\" ~ \"#fce80a\",\n      label == \"DistributedBy\" ~ \"#04f3f0\",\n      TRUE                  ~ \"#888888\"\n    )\n  )\n\n# 6. Plot with edge‐labels\nvisNetwork(vn_nodes, vn_edges, height = \"600px\", width = \"100%\") %>%\n  visNodes(shape = \"dot\", size =14, font = list(color = \"black\", size = 10)) %>%\n  visEdges(\n    arrows = \"to\",\n    labelHighlightBold = TRUE,\n    font = list(color = \"blue\", size = 8)\n  ) %>%\n  visLegend(useGroups = TRUE, width = 0.1, position = \"right\") %>%\n  visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 1234) %>%\n  visPhysics(enabled = FALSE)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-22-1.png)\n:::\n:::\n\n\n\n#### Summary of the Edge interactions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming `career_edges` is already in your environment:\n# Count interactions per edge type\nedge_summary <- career_edges %>%\n  count(`Edge Type`, name = \"Interactions\") %>%\n  arrange(Interactions)\n\n# Bar‐chart of interactions by edge type\nggplot(edge_summary, aes(\n         x = fct_reorder(`Edge Type`, Interactions),\n         y = Interactions,\n         fill = `Edge Type`\n       )) +\n  geom_col(show.legend = FALSE) +\n  coord_flip() +\n  labs(\n    title = \"Total Interactions by Edge Type\",\n    x     = NULL,\n    y     = \"Number of Links\"\n  ) +\n  theme_minimal(base_size = 12)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-23-1.png)\n:::\n:::\n\n\n:::\n\n### Leyla Graf-Gotthard\n\n::: panel-tabset\n#### Work Influence Edge Types\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2. Filter for your chosen edge types & artist\nartists2    <- c(\"Leyla Graf-Gotthard\")\nedge_types <- c(\"MemberOf\", \"ComposerOf\", \"PerformerOf\",\"LyricistOf\", \"RecordedBy\",\"ProducerOf\",\"DistributedBy\")\ncareer_edges2 <- edges_idx %>%\n  filter(`Edge Type` %in% edge_types,\n         (from %in% which(nodes_tbl$name %in% artists2)) |\n         (to   %in% which(nodes_tbl$name %in% artists2)))\n\n# 3. Prune to only the nodes in those edges\ncareer_node_ids2 <- unique(c(career_edges2$from, career_edges2$to))\ncareer_nodes2    <- nodes_tbl %>% slice(career_node_ids2)\n\n# 4. Build visNetwork node DF\nvn_nodes2 <- career_nodes2 %>%\n  mutate(\n    id    = row_number(),\n    label = name,\n    group = `Node Type`,\n    title = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`)\n  )\n\n# 5. Build visNetwork edge DF with both label & title\nid_lu2 <- tibble(old = career_node_ids2, new = vn_nodes2$id)\nvn_edges2 <- career_edges2 %>%\n  inner_join(id_lu2, by = c(\"from\" = \"old\")) %>% select(-from)  %>% rename(from = new) %>%\n  inner_join(id_lu2, by = c(\"to\"   = \"old\")) %>% select(-to)    %>% rename(to   = new) %>%\n  transmute(\n    from,\n    to,\n    label = `Edge Type`,   # drawn on the arrow\n    title = `Edge Type`,    # hover‐tooltip\n    color = case_when(\n      label == \"MemberOf\"   ~ \"#e31a1c\",\n      label == \"ComposerOf\" ~ \"#33a02c\",\n      label == \"PerformerOf\"~ \"#1f78b4\",\n      label == \"LyricistOf\" ~ \"#ff7f00\",\n      label == \"RecordedBy\" ~ \"#6a329f\",\n      label == \"ProducerOf\" ~ \"#fce80a\",\n      label == \"DistributedBy\" ~ \"#04f3f0\",\n      TRUE                  ~ \"#888888\"\n    )\n  )\n\n# 6. Plot with edge‐labels\nvisNetwork(vn_nodes2, vn_edges2, height = \"600px\", width = \"100%\") %>%\n  visNodes(shape = \"dot\", size =14, font = list(color = \"black\", size = 10)) %>%\n  visEdges(\n    arrows = \"to\",\n    labelHighlightBold = TRUE,\n    font = list(color = \"blue\", size = 8)\n  ) %>%\n  visLegend(useGroups = TRUE, width = 0.1, position = \"right\") %>%\n  visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 1234) %>%\n  visPhysics(enabled = FALSE)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-24-1.png)\n:::\n:::\n\n\n\n#### Summary of the interactions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming `career_edges` is already in your environment:\n# Count interactions per edge type\nedge_summary2 <- career_edges2 %>%\n  count(`Edge Type`, name = \"Interactions\") %>%\n  arrange(Interactions)\n\n# Bar‐chart of interactions by edge type\nggplot(edge_summary2, aes(\n         x = fct_reorder(`Edge Type`, Interactions),\n         y = Interactions,\n         fill = `Edge Type`\n       )) +\n  geom_col(show.legend = FALSE) +\n  coord_flip() +\n  labs(\n    title = \"Total Interactions by Edge Type\",\n    x     = NULL,\n    y     = \"Number of Links\"\n  ) +\n  theme_minimal(base_size = 12)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-25-1.png)\n:::\n:::\n\n\n:::\n\n### Szymon Pyć\n\n::: panel-tabset\n#### Work Influence Edge Types\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2. Filter for your chosen edge types & artist\nartists3    <- c(\"Szymon Pyć\")\nedge_types <- c(\"MemberOf\", \"ComposerOf\", \"PerformerOf\",\"LyricistOf\", \"RecordedBy\",\"ProducerOf\",\"DistributedBy\")\ncareer_edges3 <- edges_idx %>%\n  filter(`Edge Type` %in% edge_types,\n         (from %in% which(nodes_tbl$name %in% artists3)) |\n         (to   %in% which(nodes_tbl$name %in% artists3)))\n\n# 3. Prune to only the nodes in those edges\ncareer_node_ids3 <- unique(c(career_edges3$from, career_edges3$to))\ncareer_nodes3    <- nodes_tbl %>% slice(career_node_ids3)\n\n# 4. Build visNetwork node DF\nvn_nodes3 <- career_nodes3 %>%\n  mutate(\n    id    = row_number(),\n    label = name,\n    group = `Node Type`,\n    title = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`)\n  )\n\n# 5. Build visNetwork edge DF with both label & title\nid_lu3 <- tibble(old = career_node_ids3, new = vn_nodes3$id)\nvn_edges3 <- career_edges3 %>%\n  inner_join(id_lu3, by = c(\"from\" = \"old\")) %>% select(-from)  %>% rename(from = new) %>%\n  inner_join(id_lu3, by = c(\"to\"   = \"old\")) %>% select(-to)    %>% rename(to   = new) %>%\n  transmute(\n    from,\n    to,\n    label = `Edge Type`,   # drawn on the arrow\n    title = `Edge Type`,    # hover‐tooltip\n    color = case_when(\n      label == \"MemberOf\"   ~ \"#e31a1c\",\n      label == \"ComposerOf\" ~ \"#33a02c\",\n      label == \"PerformerOf\"~ \"#1f78b4\",\n      label == \"LyricistOf\" ~ \"#ff7f00\",\n      label == \"RecordedBy\" ~ \"#6a329f\",\n      label == \"ProducerOf\" ~ \"#fce80a\",\n      label == \"DistributedBy\" ~ \"#04f3f0\",\n      TRUE                  ~ \"#888888\"\n    )\n  )\n\n# 6. Plot with edge‐labels\nvisNetwork(vn_nodes3, vn_edges3, height = \"600px\", width = \"100%\") %>%\n  visNodes(shape = \"dot\", size =14, font = list(color = \"black\", size = 10)) %>%\n  visEdges(\n    arrows = \"to\",\n    labelHighlightBold = TRUE,\n    font = list(color = \"blue\", size = 8)\n  ) %>%\n  visLegend(useGroups = TRUE, width = 0.1, position = \"right\") %>%\n  visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 1234) %>%\n  visPhysics(enabled = FALSE)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-26-1.png)\n:::\n:::\n\n\n\n#### Summary of the interactions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming `career_edges` is already in your environment:\n# Count interactions per edge type\nedge_summary3 <- career_edges3 %>%\n  count(`Edge Type`, name = \"Interactions\") %>%\n  arrange(Interactions)\n\n# Bar‐chart of interactions by edge type\nggplot(edge_summary3, aes(\n         x = fct_reorder(`Edge Type`, Interactions),\n         y = Interactions,\n         fill = `Edge Type`\n       )) +\n  geom_col(show.legend = FALSE) +\n  coord_flip() +\n  labs(\n    title = \"Total Interactions by Edge Type\",\n    x     = NULL,\n    y     = \"Number of Links\"\n  ) +\n  theme_minimal(base_size = 12)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-27-1.png)\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"Work-type Influences\"}\nThese plots show the number of work influences by the artist within their scope.\n:::\n\n## Influence: People Interactions\n\nThis portion will cover how people are directly/indirectly influenced by the selected artists and their work. I will be plotting a visNetwork and barcharts for Betweenness Centrality value to show their influences.\n\n::: {.callout-note title=\"People Influences\"}\n1.  \"InterpolatesFrom\" - Indicates that the source node (Song or Album) interpolated a melody from the destination node (Song or Album).\n2.  \"DirectlySamples\" - Indicates that the source node (Song or Album) consists of (an) audio recording(s) that directly reuse a portion of the audio recording of the destination node (Song or Album) via sampling.\n3.  \"InStyleOf\" - Indicates that the source node (Song or Album) consists of (an) audio recording(s) that directly reuse a portion of the audio recording of the destination node (Song or Album) via sampling.\n4.  \"LyricalReferenceTo\" - Indicates that the source node (Song or Album) consists of (an) audio recording(s) that directly reuse a portion of the audio recording of the destination node (Song or Album) via sampling.\n5.  \"CoverOf\" - Indicates that the source node (Song or Album) is a cover of the destination node (Song or Album).\n:::\n\n**VisNetwork**\n\n-   The visNetwork will be limited to a maximum hop of 2 to reduce messiness.\n-   Dropdown select will be created to see the individual artists and their influences.\n\n**Betweenness Centrality Value**\n\n-   This measures a node's influence in a network by quantifying how often it lies on the shortest paths between other nodes.\n-   I will solely using this as information on what are the most relevant \"bridges\" controlling the flow of in the network using maximum hop of 3.\n\n### Kimberly Snyder\n\n::: panel-tabset\n#### People Influence Edges\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ─── 0. How many hops? ────────────────────────────────────────────────────────\nmax_hops <- 2   # Change this number to 1, 2, 3… then re‐run the chunk\n\n# ─── 1. Load & index all nodes and edges ────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\n# Build numeric “from/to” index for every edge\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# ─── 2. Build an undirected igraph of the full graph ────────────────────────\ng_all <- graph_from_data_frame(\n  d        = edges_idx %>% select(from, to),\n  directed = FALSE,\n  vertices = nodes_tbl %>% transmute(name = as.character(idx))\n)\n\n# ─── 3. Prepare list of all Person names for dropdown ───────────────────────\nall_persons <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  arrange(name) %>%                # sort ascending by name\n  pull(name)\n\n# ─── 4. Create a named vector mapping Person ➔ idx (character) ─────────────\nperson_idx_map <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  transmute(Person = name, idx_char = as.character(idx)) %>%\n  deframe()\n\n# ─── 5. Function to build and render a Kim‐style ego network given a name ───\nrender_ego_network <- function(center_name) {\n  center_idx <- person_idx_map[[center_name]]\n  if (is.null(center_idx)) {\n    stop(\"Person '\", center_name, \"' not found.\")\n  }\n  # Compute ego‐set of all vertices within max_hops of chosen person\n  ego_list   <- ego(g_all, order = max_hops, nodes = center_idx, mode = \"all\")[[1]]\n  ego_indices <- as.integer(V(g_all)$name[ego_list])\n  # Filter edges so both endpoints are in that ego set\n  career_edges <- edges_idx %>%\n    filter(from %in% ego_indices, to %in% ego_indices)\n  if (nrow(career_edges) == 0) {\n    showNotification(paste0(\n      \"No edges remain when limiting to \", max_hops,\n      \" hops out from \", center_name, \".\"\n    ), type = \"warning\")\n    return(NULL)\n  }\n  # Build list of all involved nodes\n  career_node_ids <- unique(c(career_edges$from, career_edges$to))\n  career_nodes    <- nodes_tbl %>% slice(career_node_ids) %>%\n    mutate(\n      vis_id = row_number(),\n      label  = name,\n      group  = `Node Type`,\n      title  = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`,\n                      if_else(`Node Type` == \"Song\" & !is.na(release_date),\n                              paste0(\"<br>Released: \", release_date), \"\"))\n    )\n  # Remap edges to vis_ids\n  career_edges <- career_edges %>%\n    mutate(\n      from_vis = match(from, career_node_ids),\n      to_vis   = match(to,   career_node_ids)\n    )\n  # Construct visNetwork nodes & edges\n  vn_nodes <- career_nodes %>%\n    transmute(id = vis_id, label = label, group = group, title = title)\n  vn_edges <- career_edges %>%\n    transmute(from = from_vis, to = to_vis, label = `Edge Type`, title = `Edge Type`,\n              color = case_when(\n                label == \"InterpolatesFrom\"   ~ \"#1f78b4\",\n                label == \"DirectlySamples\"    ~ \"#33a02c\",\n                label == \"InStyleOf\"          ~ \"#e31a1c\",\n                label == \"LyricalReferenceTo\" ~ \"#6a3d9a\",\n                label == \"CoverOf\"            ~ \"#fb9a99\",\n                label == \"ComposerOf\"         ~ \"#33a02c\",\n                label == \"PerformerOf\"        ~ \"#1f78b4\",\n                label == \"RecordedBy\"         ~ \"#6a329f\",\n                label == \"ProducerOf\"         ~ \"#fce80a\",\n                label == \"LyricistOf\"         ~ \"#ff7f00\",\n                TRUE                          ~ \"#888888\"\n              ))\n  # Determine vis_id for all Person‐type nodes (to allow dropdown focus)\n  person_vis_ids <- vn_nodes %>%\n    filter(group == \"Person\") %>%\n    arrange(label) %>%  # ensure sorted ascending\n    pull(id)\n  # Render visNetwork\n  visNetwork(vn_nodes, vn_edges, height = \"600px\", width = \"100%\") %>%\n    visNodes(shape = \"dot\", size = 14, font = list(color = \"black\", size = 10)) %>%\n    visEdges(arrows = \"to\", labelHighlightBold = TRUE, font = list(color = \"blue\", size = 7)) %>%\n    visOptions(\n      highlightNearest   = list(enabled = TRUE, degree = 1),\n      nodesIdSelection   = list(\n        enabled   = TRUE,\n        useLabels = TRUE,\n        values    = person_vis_ids\n      )\n    ) %>%\n    visLegend(useGroups = TRUE, width = 0.1, position = \"right\") %>%\n    visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 1234) %>%\n    visPhysics(enabled = FALSE)\n}\n\n# ─── 6. Initial rendering for “Kimberly Snyder” ─────────────────────────────\nrender_ego_network(\"Kimberly Snyder\")\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-28-1.png)\n:::\n:::\n\n\n\n#### Betweenness centrality in network\n\n-   Kimberly had more song influences in her network.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ─── PARAMETERS ───────────────────────────────────────────────────────────────\ncenter_person <- \"Kimberly Snyder\"\nmax_hops      <- 3\nkeep_edge_types <- c(\n  \"InterpolatesFrom\", \"InStyleOf\", \"LyricalReferenceTo\",\n  \"CoverOf\", \"DirectlySamples\",\n  \"ComposerOf\", \"PerformerOf\", \"MemberOf\", \"Released\"\n)\n\n# ─── 1. Load & index all nodes and edges ────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# ─── 2. Build an undirected igraph of the full graph (topology only) ────────\ng_all <- graph_from_data_frame(\n  d        = edges_idx %>% select(from, to),\n  directed = FALSE,\n  vertices = nodes_tbl %>% transmute(name = as.character(idx))\n)\n\n# ─── 3. Find the chosen person’s idx (character) ────────────────────────────\ncenter_idx_char <- nodes_tbl %>%\n  filter(name == center_person, `Node Type` == \"Person\") %>%\n  pull(idx) %>%\n  as.character()\nif (length(center_idx_char) != 1) {\n  stop(\"Person '\", center_person, \"' not found or not unique.\")\n}\n\n# ─── 4. Compute the ego‐set of vertices within max_hops of the center ────────\nego_list   <- ego(g_all, order = max_hops, nodes = center_idx_char, mode = \"all\")[[1]]\nego_indices <- as.integer(V(g_all)$name[ego_list])  # numeric idx of all nodes in ego‐set\n\n# ─── 5. Filter edges so that both endpoints lie in that ego‐set AND edge‐type is in keep_edge_types ─\nego_edges <- edges_idx %>%\n  filter(\n    from %in% ego_indices,\n    to   %in% ego_indices,\n    `Edge Type` %in% keep_edge_types\n  )\n\nif (nrow(ego_edges) == 0) {\n  message(\"No edges remain when limiting to \", max_hops, \" hop(s) around \", center_person, \".\")\n} else {\n  # ─── 6. Build the list of involved nodes in this ego‐set ─────────────────────\n  ego_node_ids <- unique(c(ego_edges$from, ego_edges$to))\n  ego_nodes    <- nodes_tbl %>% slice(ego_node_ids)\n  \n  # ─── 7. Construct an igraph for this ego network ───────────────────────────\n  vertices_df <- ego_nodes %>%\n    transmute(name = as.character(idx), label = name, type = `Node Type`)\n  edges_df <- ego_edges %>%\n    transmute(from = as.character(from), to = as.character(to), etype = `Edge Type`)\n  \n  g_ego <- graph_from_data_frame(\n    d        = edges_df %>% select(from, to),\n    directed = FALSE,\n    vertices = vertices_df\n  )\n  \n  # ─── 8. Compute betweenness centrality for every vertex ────────────────────\n  bc_vals <- betweenness(g_ego, directed = FALSE, normalized = TRUE)\n  centrality_tbl <- tibble(\n    idx         = as.integer(names(bc_vals)),\n    betweenness = unname(bc_vals)\n  ) %>%\n    left_join(\n      ego_nodes %>% select(idx, NodeName = name, NodeType = `Node Type`),\n      by = \"idx\"\n    ) %>%\n    arrange(desc(betweenness))\n  \n  \n  # ─── 9. Bar‐chart of top 10 nodes by betweenness ──────────────────────────\n  centrality_tbl %>%\n    slice_head(n = 10) %>%\n    ggplot(aes(x = fct_reorder(NodeName, betweenness), y = betweenness, fill = NodeType)) +\n    geom_col(show.legend = TRUE) +\n    coord_flip() +\n    labs(\n      title = paste0(\"Top 10 Nodes by Betweenness (\", max_hops, \"-hop around \", center_person, \")\"),\n      x     = NULL,\n      y     = \"Betweenness (normalized)\"\n    ) +\n    theme_minimal(base_size = 9) +\n    theme(\n      plot.title    = element_text(size = 10, face = \"bold\"),\n      axis.title.y  = element_text(size = 5),\n      axis.title.x  = element_text(size = 10)\n    )\n}\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-29-1.png)\n:::\n:::\n\n\n:::\n\n### Leyla Graf-Gotthard\n\n::: panel-tabset\n#### People Influence Edges\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ─── 0. How many hops? ────────────────────────────────────────────────────────\nmax_hops <- 2   # Change this number to 1, 2, 3… then re‐run the chunk\n\n# ─── 1. Load & index all nodes and edges ────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\n# Build numeric “from/to” index for every edge\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# ─── 2. Build an undirected igraph of the full graph ────────────────────────\ng_all <- graph_from_data_frame(\n  d        = edges_idx %>% select(from, to),\n  directed = FALSE,\n  vertices = nodes_tbl %>% transmute(name = as.character(idx))\n)\n\n# ─── 3. Prepare list of all Person names for dropdown ───────────────────────\nall_persons <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  arrange(name) %>%                # sort ascending by name\n  pull(name)\n\n# ─── 4. Create a named vector mapping Person ➔ idx (character) ─────────────\nperson_idx_map <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  transmute(Person = name, idx_char = as.character(idx)) %>%\n  deframe()\n\n# ─── 5. Function to build and render a Leyla‐style ego network given a name ───\nrender_ego_network <- function(center_name) {\n  center_idx <- person_idx_map[[center_name]]\n  if (is.null(center_idx)) {\n    stop(\"Person '\", center_name, \"' not found.\")\n  }\n  # Compute ego‐set of all vertices within max_hops of chosen person\n  ego_list   <- ego(g_all, order = max_hops, nodes = center_idx, mode = \"all\")[[1]]\n  ego_indices <- as.integer(V(g_all)$name[ego_list])\n  # Filter edges so both endpoints are in that ego set\n  career_edges <- edges_idx %>%\n    filter(from %in% ego_indices, to %in% ego_indices)\n  if (nrow(career_edges) == 0) {\n    showNotification(paste0(\n      \"No edges remain when limiting to \", max_hops,\n      \" hops out from \", center_name, \".\"\n    ), type = \"warning\")\n    return(NULL)\n  }\n  # Build list of all involved nodes\n  career_node_ids <- unique(c(career_edges$from, career_edges$to))\n  career_nodes    <- nodes_tbl %>% slice(career_node_ids) %>%\n    mutate(\n      vis_id = row_number(),\n      label  = name,\n      group  = `Node Type`,\n      title  = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`,\n                      if_else(`Node Type` == \"Song\" & !is.na(release_date),\n                              paste0(\"<br>Released: \", release_date), \"\"))\n    )\n  # Remap edges to vis_ids\n  career_edges <- career_edges %>%\n    mutate(\n      from_vis = match(from, career_node_ids),\n      to_vis   = match(to,   career_node_ids)\n    )\n  # Construct visNetwork nodes & edges\n  vn_nodes <- career_nodes %>%\n    transmute(id = vis_id, label = label, group = group, title = title)\n  vn_edges <- career_edges %>%\n    transmute(from = from_vis, to = to_vis, label = `Edge Type`, title = `Edge Type`,\n              color = case_when(\n                label == \"InterpolatesFrom\"   ~ \"#1f78b4\",\n                label == \"DirectlySamples\"    ~ \"#33a02c\",\n                label == \"InStyleOf\"          ~ \"#e31a1c\",\n                label == \"LyricalReferenceTo\" ~ \"#6a3d9a\",\n                label == \"CoverOf\"            ~ \"#fb9a99\",\n                label == \"ComposerOf\"         ~ \"#33a02c\",\n                label == \"PerformerOf\"        ~ \"#1f78b4\",\n                label == \"RecordedBy\"         ~ \"#6a329f\",\n                label == \"ProducerOf\"         ~ \"#fce80a\",\n                label == \"LyricistOf\"         ~ \"#ff7f00\",\n                TRUE                          ~ \"#888888\"\n              ))\n  # Determine vis_id for all Person‐type nodes (to allow dropdown focus)\n  person_vis_ids <- vn_nodes %>%\n    filter(group == \"Person\") %>%\n    arrange(label) %>%  # ensure sorted ascending\n    pull(id)\n  # Render visNetwork\n  visNetwork(vn_nodes, vn_edges, height = \"600px\", width = \"100%\") %>%\n    visNodes(shape = \"dot\", size = 14, font = list(color = \"black\", size = 10)) %>%\n    visEdges(arrows = \"to\", labelHighlightBold = TRUE, font = list(color = \"blue\", size = 7)) %>%\n    visOptions(\n      highlightNearest   = list(enabled = TRUE, degree = 1),\n      nodesIdSelection   = list(\n        enabled   = TRUE,\n        useLabels = TRUE,\n        values    = person_vis_ids\n      )\n    ) %>%\n    visLegend(useGroups = TRUE, width = 0.1, position = \"right\") %>%\n    visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 1234) %>%\n    visPhysics(enabled = FALSE)\n}\n\n# ─── 6. Initial rendering for “Kimberly Snyder” ─────────────────────────────\nrender_ego_network(\"Leyla Graf-Gotthard\")\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-30-1.png)\n:::\n:::\n\n\n\n#### Betweenness centrality in network\n\n-   Similarly, Leyla had more song influences in her network.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ─── PARAMETERS ───────────────────────────────────────────────────────────────\ncenter_person <- \"Leyla Graf-Gotthard\"\nmax_hops      <- 3\nkeep_edge_types <- c(\n  \"InterpolatesFrom\", \"InStyleOf\", \"LyricalReferenceTo\",\n  \"CoverOf\", \"DirectlySamples\",\n  \"ComposerOf\", \"PerformerOf\", \"MemberOf\", \"Released\"\n)\n\n# ─── 1. Load & index all nodes and edges ────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# ─── 2. Build an undirected igraph of the full graph (topology only) ────────\ng_all <- graph_from_data_frame(\n  d        = edges_idx %>% select(from, to),\n  directed = FALSE,\n  vertices = nodes_tbl %>% transmute(name = as.character(idx))\n)\n\n# ─── 3. Find the chosen person’s idx (character) ────────────────────────────\ncenter_idx_char <- nodes_tbl %>%\n  filter(name == center_person, `Node Type` == \"Person\") %>%\n  pull(idx) %>%\n  as.character()\nif (length(center_idx_char) != 1) {\n  stop(\"Person '\", center_person, \"' not found or not unique.\")\n}\n\n# ─── 4. Compute the ego‐set of vertices within max_hops of the center ────────\nego_list   <- ego(g_all, order = max_hops, nodes = center_idx_char, mode = \"all\")[[1]]\nego_indices <- as.integer(V(g_all)$name[ego_list])  # numeric idx of all nodes in ego‐set\n\n# ─── 5. Filter edges so that both endpoints lie in that ego‐set AND edge‐type is in keep_edge_types ─\nego_edges <- edges_idx %>%\n  filter(\n    from %in% ego_indices,\n    to   %in% ego_indices,\n    `Edge Type` %in% keep_edge_types\n  )\n\nif (nrow(ego_edges) == 0) {\n  message(\"No edges remain when limiting to \", max_hops, \" hop(s) around \", center_person, \".\")\n} else {\n  # ─── 6. Build the list of involved nodes in this ego‐set ─────────────────────\n  ego_node_ids <- unique(c(ego_edges$from, ego_edges$to))\n  ego_nodes    <- nodes_tbl %>% slice(ego_node_ids)\n  \n  # ─── 7. Construct an igraph for this ego network ───────────────────────────\n  vertices_df <- ego_nodes %>%\n    transmute(name = as.character(idx), label = name, type = `Node Type`)\n  edges_df <- ego_edges %>%\n    transmute(from = as.character(from), to = as.character(to), etype = `Edge Type`)\n  \n  g_ego <- graph_from_data_frame(\n    d        = edges_df %>% select(from, to),\n    directed = FALSE,\n    vertices = vertices_df\n  )\n  \n  # ─── 8. Compute betweenness centrality for every vertex ────────────────────\n  bc_vals <- betweenness(g_ego, directed = FALSE, normalized = TRUE)\n  centrality_tbl <- tibble(\n    idx         = as.integer(names(bc_vals)),\n    betweenness = unname(bc_vals)\n  ) %>%\n    left_join(\n      ego_nodes %>% select(idx, NodeName = name, NodeType = `Node Type`),\n      by = \"idx\"\n    ) %>%\n    arrange(desc(betweenness))\n  \n  # ─── 9. Bar‐chart of top 10 nodes by betweenness ──────────────────────────\n  centrality_tbl %>%\n    slice_head(n = 10) %>%\n    ggplot(aes(x = fct_reorder(NodeName, betweenness), y = betweenness, fill = NodeType)) +\n    geom_col(show.legend = TRUE) +\n    coord_flip() +\n    labs(\n      title = paste0(\"Top 10 Nodes by Betweenness (\", max_hops, \"-hop around \", center_person, \")\"),\n      x     = NULL,\n      y     = \"Betweenness (normalized)\"\n    ) +\n        theme_minimal(base_size = 9) +\n    theme(\n      plot.title    = element_text(size = 10, face = \"bold\"),\n      axis.title.y  = element_text(size = 5),\n      axis.title.x  = element_text(size = 10)\n    )\n}\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-31-1.png)\n:::\n:::\n\n\n:::\n\n### Szymon Pyć\n\n::: panel-tabset\n#### People Influence Edges\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ─── 0. How many hops? ────────────────────────────────────────────────────────\nmax_hops <- 2   # Change this number to 1, 2, 3… then re‐run the chunk\n\n# ─── 1. Load & index all nodes and edges ────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\n# Build numeric “from/to” index for every edge\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# ─── 2. Build an undirected igraph of the full graph ────────────────────────\ng_all <- graph_from_data_frame(\n  d        = edges_idx %>% select(from, to),\n  directed = FALSE,\n  vertices = nodes_tbl %>% transmute(name = as.character(idx))\n)\n\n# ─── 3. Prepare list of all Person names for dropdown ───────────────────────\nall_persons <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  arrange(name) %>%                # sort ascending by name\n  pull(name)\n\n# ─── 4. Create a named vector mapping Person ➔ idx (character) ─────────────\nperson_idx_map <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  transmute(Person = name, idx_char = as.character(idx)) %>%\n  deframe()\n\n# ─── 5. Function to build and render a Leyla‐style ego network given a name ───\nrender_ego_network <- function(center_name) {\n  center_idx <- person_idx_map[[center_name]]\n  if (is.null(center_idx)) {\n    stop(\"Person '\", center_name, \"' not found.\")\n  }\n  # Compute ego‐set of all vertices within max_hops of chosen person\n  ego_list   <- ego(g_all, order = max_hops, nodes = center_idx, mode = \"all\")[[1]]\n  ego_indices <- as.integer(V(g_all)$name[ego_list])\n  # Filter edges so both endpoints are in that ego set\n  career_edges <- edges_idx %>%\n    filter(from %in% ego_indices, to %in% ego_indices)\n  if (nrow(career_edges) == 0) {\n    showNotification(paste0(\n      \"No edges remain when limiting to \", max_hops,\n      \" hops out from \", center_name, \".\"\n    ), type = \"warning\")\n    return(NULL)\n  }\n  # Build list of all involved nodes\n  career_node_ids <- unique(c(career_edges$from, career_edges$to))\n  career_nodes    <- nodes_tbl %>% slice(career_node_ids) %>%\n    mutate(\n      vis_id = row_number(),\n      label  = name,\n      group  = `Node Type`,\n      title  = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`,\n                      if_else(`Node Type` == \"Song\" & !is.na(release_date),\n                              paste0(\"<br>Released: \", release_date), \"\"))\n    )\n  # Remap edges to vis_ids\n  career_edges <- career_edges %>%\n    mutate(\n      from_vis = match(from, career_node_ids),\n      to_vis   = match(to,   career_node_ids)\n    )\n  # Construct visNetwork nodes & edges\n  vn_nodes <- career_nodes %>%\n    transmute(id = vis_id, label = label, group = group, title = title)\n  vn_edges <- career_edges %>%\n    transmute(from = from_vis, to = to_vis, label = `Edge Type`, title = `Edge Type`,\n              color = case_when(\n                label == \"InterpolatesFrom\"   ~ \"#1f78b4\",\n                label == \"DirectlySamples\"    ~ \"#33a02c\",\n                label == \"InStyleOf\"          ~ \"#e31a1c\",\n                label == \"LyricalReferenceTo\" ~ \"#6a3d9a\",\n                label == \"CoverOf\"            ~ \"#fb9a99\",\n                label == \"ComposerOf\"         ~ \"#33a02c\",\n                label == \"PerformerOf\"        ~ \"#1f78b4\",\n                label == \"RecordedBy\"         ~ \"#6a329f\",\n                label == \"ProducerOf\"         ~ \"#fce80a\",\n                label == \"LyricistOf\"         ~ \"#ff7f00\",\n                TRUE                          ~ \"#888888\"\n              ))\n  # Determine vis_id for all Person‐type nodes (to allow dropdown focus)\n  person_vis_ids <- vn_nodes %>%\n    filter(group == \"Person\") %>%\n    arrange(label) %>%  # ensure sorted ascending\n    pull(id)\n  # Render visNetwork\n  visNetwork(vn_nodes, vn_edges, height = \"600px\", width = \"100%\") %>%\n    visNodes(shape = \"dot\", size = 14, font = list(color = \"black\", size = 10)) %>%\n    visEdges(arrows = \"to\", labelHighlightBold = TRUE, font = list(color = \"blue\", size = 7)) %>%\n    visOptions(\n      highlightNearest   = list(enabled = TRUE, degree = 1),\n      nodesIdSelection   = list(\n        enabled   = TRUE,\n        useLabels = TRUE,\n        values    = person_vis_ids\n      )\n    ) %>%\n    visLegend(useGroups = TRUE, width = 0.1, position = \"right\") %>%\n    visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 1234) %>%\n    visPhysics(enabled = FALSE)\n}\n\n# ─── 6. Initial rendering for “Kimberly Snyder” ─────────────────────────────\nrender_ego_network(\"Szymon Pyć\")\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-32-1.png)\n:::\n:::\n\n\n\n#### Betweenness centrality in network\n\n-   Interestingly, there were more albums and people influence in Szymon's network.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ─── PARAMETERS ───────────────────────────────────────────────────────────────\ncenter_person <- \"Szymon Pyć\"\nmax_hops      <- 3\nkeep_edge_types <- c(\n  \"InterpolatesFrom\", \"InStyleOf\", \"LyricalReferenceTo\",\n  \"CoverOf\", \"DirectlySamples\",\n  \"ComposerOf\", \"PerformerOf\", \"MemberOf\", \"Released\"\n)\n\n# ─── 1. Load & index all nodes and edges ────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# ─── 2. Build an undirected igraph of the full graph (topology only) ────────\ng_all <- graph_from_data_frame(\n  d        = edges_idx %>% select(from, to),\n  directed = FALSE,\n  vertices = nodes_tbl %>% transmute(name = as.character(idx))\n)\n\n# ─── 3. Find the chosen person’s idx (character) ────────────────────────────\ncenter_idx_char <- nodes_tbl %>%\n  filter(name == center_person, `Node Type` == \"Person\") %>%\n  pull(idx) %>%\n  as.character()\nif (length(center_idx_char) != 1) {\n  stop(\"Person '\", center_person, \"' not found or not unique.\")\n}\n\n# ─── 4. Compute the ego‐set of vertices within max_hops of the center ────────\nego_list   <- ego(g_all, order = max_hops, nodes = center_idx_char, mode = \"all\")[[1]]\nego_indices <- as.integer(V(g_all)$name[ego_list])  # numeric idx of all nodes in ego‐set\n\n# ─── 5. Filter edges so that both endpoints lie in that ego‐set AND edge‐type is in keep_edge_types ─\nego_edges <- edges_idx %>%\n  filter(\n    from %in% ego_indices,\n    to   %in% ego_indices,\n    `Edge Type` %in% keep_edge_types\n  )\n\nif (nrow(ego_edges) == 0) {\n  message(\"No edges remain when limiting to \", max_hops, \" hop(s) around \", center_person, \".\")\n} else {\n  # ─── 6. Build the list of involved nodes in this ego‐set ─────────────────────\n  ego_node_ids <- unique(c(ego_edges$from, ego_edges$to))\n  ego_nodes    <- nodes_tbl %>% slice(ego_node_ids)\n  \n  # ─── 7. Construct an igraph for this ego network ───────────────────────────\n  vertices_df <- ego_nodes %>%\n    transmute(name = as.character(idx), label = name, type = `Node Type`)\n  edges_df <- ego_edges %>%\n    transmute(from = as.character(from), to = as.character(to), etype = `Edge Type`)\n  \n  g_ego <- graph_from_data_frame(\n    d        = edges_df %>% select(from, to),\n    directed = FALSE,\n    vertices = vertices_df\n  )\n  \n  # ─── 8. Compute betweenness centrality for every vertex ────────────────────\n  bc_vals <- betweenness(g_ego, directed = FALSE, normalized = TRUE)\n  centrality_tbl <- tibble(\n    idx         = as.integer(names(bc_vals)),\n    betweenness = unname(bc_vals)\n  ) %>%\n    left_join(\n      ego_nodes %>% select(idx, NodeName = name, NodeType = `Node Type`),\n      by = \"idx\"\n    ) %>%\n    arrange(desc(betweenness))\n  \n  # ─── 9. Bar‐chart of top 10 nodes by betweenness ──────────────────────────\n  centrality_tbl %>%\n    slice_head(n = 10) %>%\n    ggplot(aes(x = fct_reorder(NodeName, betweenness), y = betweenness, fill = NodeType)) +\n    geom_col(show.legend = TRUE) +\n    coord_flip() +\n    labs(\n      title = paste0(\"Top 10 Nodes by Betweenness (\", max_hops, \"-hop around \", center_person, \")\"),\n      x     = NULL,\n      y     = \"Betweenness (normalized)\"\n    ) +\n        theme_minimal(base_size = 9) +\n    theme(\n      plot.title    = element_text(size = 10, face = \"bold\"),\n      axis.title.y  = element_text(size = 5),\n      axis.title.x  = element_text(size = 10)\n    )\n}\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-33-1.png)\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"People Influence\"}\nThese plots depict that each artist has a difference in which external node (song/album/person) had the most influence and control.\n:::\n\n## Additional: Affliation works with Musical Groups\n\n-   I want to visualise the categories for Kimberly Snyder's Sonic Renegades and their members.\n\n-   Only Kimberly Snyder has an affliated musicalgroup as Leyla Graf-Gotthard and Szymon Pyć are supposedly solo artists as there isnt any nodes linking them to a group.\n\n### Kimberly Snyder and Sonic Renegade members\n\nFollowing factors are used to visualize Kimberly and her members.\n\n-   \"MemberOf\", \"ComposerOf\", \"PerformerOf\",\"LyricistOf\", \"RecordedBy\",\"ProducerOf\",\"DistributedBy\"\n\n#### MusicalGroup Linkages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#── Ingest your graph data ────────────────────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes)\nedges_tbl <- as_tibble(kg_raw$links)\n\n#── Map source/target to row indices ──────────────────────────────────────────\nid_map <- nodes_tbl %>% \n  mutate(index = row_number()) %>% \n  select(id, index)\n\nedges_idx <- edges_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>% rename(from = index) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>% rename(to   = index) %>%\n  filter(!is.na(from) & !is.na(to))\n\n#── Define your five Sonic Renegade members ────────────────────────────────────────\nartists <- c(\n  \"Kimberly Snyder\",\n  \"Gerald Mullins\",\n  \"Kelly Stewart\",\n  \"Joshua Herring\"\n)\n\n#── Pull only the relevant edges for those artists ────────────────────────────\ncareer_edges <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"MemberOf\", \"ComposerOf\", \"PerformerOf\",\"LyricistOf\", \"RecordedBy\",\"ProducerOf\",\"DistributedBy\")) %>%\n  filter(\n    from %in% which(nodes_tbl$name %in% artists) |\n    to   %in% which(nodes_tbl$name %in% artists)\n  )\n\n#── Slice out all involved nodes ──────────────────────────────────────────────\ncareer_node_ids <- unique(c(career_edges$from, career_edges$to))\ncareer_nodes    <- nodes_tbl %>% slice(career_node_ids)\n\n#── Build visNetwork nodes df (uniform sizing) ───────────────────────────────\nvn_nodes <- career_nodes %>%\n  mutate(\n    id    = row_number(),\n    label = name,\n    group = `Node Type`,\n    value = 1\n  )\n\n#── Remap edges to the new vn_node ids ────────────────────────────────────────\nid_lookup <- tibble(old = career_node_ids, new = vn_nodes$id)\n\nvn_edges <- career_edges %>%\n  inner_join(id_lookup, by = c(\"from\" = \"old\")) %>%\n    select(-from) %>% rename(from = new) %>%\n  inner_join(id_lookup, by = c(\"to\" = \"old\")) %>%\n    select(-to)   %>% rename(to   = new) %>%\n  select(from, to, title = `Edge Type`)\n\n#── Plot ─────────────────────────────────────────────────────────────────────\nvisNetwork(vn_nodes, vn_edges, height = \"600px\", width = \"100%\") %>%\n  visNodes(shape = \"dot\", scaling = list(min = 5, max = 30)) %>%\n  visEdges(arrows = \"to\") %>%\n  visLegend(width = 0.1, position = \"right\") %>%\n  visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 1234) %>%\n  visPhysics(enabled = FALSE)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-34-1.png)\n:::\n:::\n\n\n\n#### Timeline of Sonic Renegade' members works\n\n-   I would like to view the timeline of the works by each of the members to see who has been having consistent work throughout the years.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\nlibrary(tidyr)       # for unnest_wider()\n\n# 1. Load & index graph (as before) -----------------------------\nkg_raw      <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl   <- as_tibble(kg_raw$nodes)\nlinks_tbl   <- as_tibble(kg_raw$links)\n\nivy_id_map  <- nodes_tbl %>% \n  mutate(ivy_row = row_number()) %>% \n  select(id, ivy_row)\n\nivy_edges   <- links_tbl %>%\n  left_join(ivy_id_map, by = c(\"source\" = \"id\")) %>% rename(from = ivy_row) %>%\n  left_join(ivy_id_map, by = c(\"target\" = \"id\")) %>% rename(to   = ivy_row) %>%\n  filter(!is.na(from), !is.na(to))\n\n# 2. Get Ivy Echos members ---------------------------------------\nband_idx     <- which(nodes_tbl$name == \"Sonic Renegade\")\nmember_idxs  <- ivy_edges %>%\n  filter(`Edge Type` == \"MemberOf\", to == band_idx) %>%\n  pull(from)\nmember_names <- nodes_tbl$name[member_idxs]\n\n# 3. Filter to their ComposerOf/PerformerOf and extract years ----\nrelease_edges <- ivy_edges %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\",\"PerformerOf\",\"LyricistOf\", \"RecordedBy\",\"ProducerOf\",\"DistributedBy\"),\n         from %in% member_idxs)\n\nrelease_data  <- release_edges %>%\n  mutate(\n    Artist = nodes_tbl$name[from],\n    Year   = as.integer(nodes_tbl$release_date[to])\n  ) %>%\n  filter(!is.na(Year))\n\n# 4. Summarize & “complete” zero years ---------------------------\nraw_counts <- release_data %>%\n  count(Artist, Year)\n\n# determine full span of years in your dataset\nyear_span <- seq(min(raw_counts$Year), max(raw_counts$Year))\n\ntimeline_tbl <- raw_counts %>%\n  complete(\n    Artist = member_names,\n    Year   = year_span,\n    fill   = list(n = 0)\n  )\n\n# 5. Plot with zeros shown ----------------------------------------\nggplot(timeline_tbl %>% mutate(Year_f = factor(Year)), \n       aes(x = Year_f, y = n, color = Artist, group = Artist)) +\n  geom_line(position = position_dodge(width = 0.5), size = 1) +\n  geom_point(position = position_dodge(width = 0.5), size = 3) +\n  scale_x_discrete(drop = FALSE) +\n  labs(\n    title = \"Annual Output by Sonic Renegade Members (Dodged)\",\n    x     = \"Year\",\n    y     = \"Number of Works\",\n    color = \"Artist\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-35-1.png)\n:::\n:::\n\n\n\n::: {.callout-note title=\"Additional\"}\nBased on the above plot, the trend of how many songs released by each member is similar. However, Kimberly Snyder has more songs each year as compared to the other group members.\n\nThis could also show how Kimberly had more notable songs due to more effort in producing songs each year which lead to her immense popularity and influence.\n:::\n\n## **Summary of part (a)**\n\n1.  Notable songs and release across the years are important factors for artist's popularity.\n\n2.  External factors such as influences factors show how much control and spread of the artist's information is spread across to people.\n\n# Question 3 Part (b)\n\n<span style=\"color:red;\">Part (b): **Using this characterization, give three predictions of who the next Oceanus Folk stars with be over the next five years**</span>\n\nTo predict the next Oceanus Folk stars over the next 5 years, I would need to check on the popularity + influence nodes that was done in part (a). I will see if there is a pattern in the plots and predict from there who I think will be the next upcoming stars.\n\n::: {.callout-note title=\"Factors to consider\"}\n1.  Count of Notable songs\n2.  Years since 1st release song (Limiting the years since the artist's first released song\")\n3.  Betweenness Centrality score in Oceanus Folk genre\n4.  Similar pattern to Top Stars in industry\n5.  Advisable to check artists as individuals and not between group members as some might be an older veteran in the industry\n:::\n\n## Popularity\n\n### Number of Notable songs of Oceanus Folk\n\n-   Let's take a look at all the songs + notable songs released by Oceanus Folk throughout their careers.\n-   I will do a global count of every Oceanus Folk song marked \"notable == True\" to have an overview without any restrictions.\n-   I will plot the total songs released beside the notable songs barchart as comparison.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Load & index the graph\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% \n  mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\n\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# 2. Identify all Person nodes\nperson_idxs <- which(nodes_tbl$`Node Type` == \"Person\")\n\n# 3a. Count all Oceanus Folk songs per Person\ntotal_oceanus_tbl <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n         from %in% person_idxs) %>%\n  left_join(\n    nodes_tbl %>% select(idx, genre, `Node Type`),\n    by = c(\"to\" = \"idx\")\n  ) %>%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\") %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"TotalOceanusSongs\")\n\n# 3b. Count only notable Oceanus Folk songs per Person\nnotable_oceanus_tbl <- edges_idx %>%\n  filter(`Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n         from %in% person_idxs) %>%\n  left_join(\n    nodes_tbl %>% select(idx, notable, genre, `Node Type`),\n    by = c(\"to\" = \"idx\")\n  ) %>%\n  filter(`Node Type` == \"Song\",\n         genre == \"Oceanus Folk\",\n         notable == TRUE) %>%\n  mutate(Person = nodes_tbl$name[from]) %>%\n  count(Person, name = \"NotableOceanusSongs\")\n\n# 4. Join total & notable counts, replace missing with 0\ncombined_tbl <- full_join(total_oceanus_tbl, notable_oceanus_tbl, by = \"Person\") %>%\n  replace_na(list(TotalOceanusSongs = 0, NotableOceanusSongs = 0)) %>%\n  arrange(desc(NotableOceanusSongs))\n\n# 5. Take top 15 by Notable count, then reorder factor by Notable\ntop_n <- 15\nplot_tbl <- combined_tbl %>%\n  slice_head(n = top_n) %>%\n  mutate(Person = fct_reorder(Person, NotableOceanusSongs))\n\n# 6. Pivot to long form for grouped/stacked bar plotting\nplot_long <- plot_tbl %>%\n  pivot_longer(cols = c(TotalOceanusSongs, NotableOceanusSongs),\n               names_to = \"Metric\", values_to = \"Count\")\n\n# 7. Plot side-by-side columns: Total vs Notable\nggplot(plot_long, aes(x = Person, y = Count, fill = Metric)) +\n  geom_col(position = position_dodge(width = 0.7), width = 0.6) +\n  coord_flip() +\n  scale_fill_manual(\n    values = c(\n      TotalOceanusSongs   = \"#a6cee3\",\n      NotableOceanusSongs = \"#1f78b4\"\n    ),\n    labels = c(\"Total Songs\", \"Notable Songs\")\n  ) +\n  labs(\n    title = \"Top Persons by Oceanus Folk Output (Total vs. Notable)\",\n    x     = NULL,\n    y     = \"Number of Songs\",\n    fill  = \"Metric\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    legend.position = \"top\",\n    axis.text.y     = element_text(size = 10),\n    plot.title      = element_text(size = 14, face = \"bold\")\n  )\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-36-1.png)\n:::\n:::\n\n\n\n::: {.callout-note title=\"Overall Artists in Oceanus Folk\"}\nYou can see the spread of artists with notable songs but we have yet to limit the years as we are not interested in long-careered artists but **rising artists**.\n:::\n\n### Songs timeline\n\nI will plot these songs across the years to visualize which years we should set as our limit.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n\n# 1. Load & index the graph\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>%\n  mutate(idx = row_number())\n\n# 2. Filter to Oceanus Folk Song nodes and extract their year + notable flag\noceanus_songs <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\") %>%\n  mutate(\n    # Parse release_date and written_date to integers (YYYY)\n    release_year = suppressWarnings(as.integer(str_extract(release_date, \"\\\\d{4}\"))),\n    written_year = suppressWarnings(as.integer(str_extract(written_date, \"\\\\d{4}\"))),\n    # Choose the earliest non-NA year as the official song_year\n    song_year    = pmin(release_year, written_year, na.rm = TRUE),\n    # Flag whether this song is “notable” (has a notoriety_date)\n    is_notable   = !is.na(notoriety_date)\n  ) %>%\n  # Only keep those with a valid song_year ≤ 2040\n  filter(!is.na(song_year), song_year <= 2040) %>%\n  select(idx, song_year, is_notable)\n\n# 3. Determine the earliest Oceanus Folk “debut” year\ndebut_year <- min(oceanus_songs$song_year, na.rm = TRUE)\n\n# 4. Build a data frame of year-by-year counts from debut_year through 2040\nyear_seq <- tibble(year = seq(debut_year, 2040))\n\nyearly_counts <- oceanus_songs %>%\n  group_by(song_year) %>%\n  summarize(\n    total_releases   = n(),\n    total_notable    = sum(is_notable),\n    .groups = \"drop\"\n  ) %>%\n  rename(year = song_year)\n\n# 5. Left-join to ensure we include years with zero releases/notable\nyearly_trends <- year_seq %>%\n  left_join(yearly_counts, by = \"year\") %>%\n  replace_na(list(total_releases = 0, total_notable = 0))\n\n# 6. Plot both series on the same plot\nggplot(yearly_trends, aes(x = year)) +\n  geom_col(aes(y = total_releases), fill = \"steelblue\", alpha = 0.6) +\n  geom_line(aes(y = total_notable), color = \"darkred\", size = 1) +\n  geom_point(aes(y = total_notable), color = \"darkred\", size = 2) +\n  scale_x_continuous(breaks = seq(debut_year, 2040, by = 2)) +\n  labs(\n    title = \"Oceanus Folk: Annual Song Releases and Notable Songs (to 2040)\",\n    subtitle = paste0(\"Data from first Oceanus Folk release (\", debut_year, \") through 2040\"),\n    x = \"Year\",\n    y = \"Count\",\n    caption = \"Blue bars = total Oceanus Folk songs released; Red line = notable songs\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title    = element_text(size = 8, face = \"bold\"),\n    plot.subtitle = element_text(size = 10),\n    axis.text.x   = element_text(angle = 45, hjust = 1)\n  )\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-37-1.png)\n:::\n:::\n\n\n\n::: {.callout-note title=\"Timeline Note\"}\n-   There weren't any notable songs released by the Oceanus Folk artists from 2036 to 2040.\n-   Based on this, I will want to limit the spread to around 10 years since the last notable song in 2035.\n-   The range I will select to determine my 3 rising stars will be from **2025 to 2035**.\n:::\n\n## Direct Prediction based on notable songs\n\n-   Below is a direct prediction on the **top 3 “next Oceanus Folk stars”** based on limiting the notable songs and release years from 2025 to 2035.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DT)\nlibrary(lubridate)\n\n# ─── 0. PARAMETERS ─────────────────────────────────────────────────────────────\nwindow_start       <- 2025\nwindow_end         <- 2035\nearly_window_years <- 5\ninfluence_edge_types <- c(\n  \"InterpolatesFrom\",\n  \"CoverOf\",\n  \"LyricalReferenceTo\",\n  \"DirectlySamples\",\n  \"InStyleOf\"\n)\n\n# ─── 1. LOAD & PREPARE NODES + EDGES ───────────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>%\n  mutate(idx = row_number())  # numeric index for joining\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from), !is.na(to))\n\n# ─── 2. EXTRACT “OCEANUS FOLK” SONGS & THEIR FIRST‐RELEASE YEARS ─────────────\nsongs_oceanus <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\") %>%\n  mutate(\n    release_year = suppressWarnings(as.integer(str_extract(release_date, \"\\\\d{4}\"))),\n    written_year = suppressWarnings(as.integer(str_extract(written_date, \"\\\\d{4}\"))),\n    first_year   = pmin(release_year, written_year, na.rm = TRUE)\n  ) %>%\n  filter(!is.na(first_year)) %>%\n  filter(first_year >= window_start, first_year <= window_end) %>%\n  select(song_idx = idx, first_year)\n\nperson_idxs <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  pull(idx)\n\nperson_song_edges <- edges_idx %>%\n  filter(\n    `Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n    from %in% person_idxs,\n    to   %in% songs_oceanus$song_idx\n  ) %>%\n  select(person_idx = from, song_idx = to)\n\nperson_first_oceanus <- person_song_edges %>%\n  left_join(songs_oceanus, by = \"song_idx\") %>%\n  group_by(person_idx) %>%\n  summarise(first_oceanus_year = min(first_year, na.rm = TRUE), .groups = \"drop\") %>%\n  filter(first_oceanus_year >= window_start, first_oceanus_year <= window_end)\n\nif (nrow(person_first_oceanus) == 0) {\n  stop(\"No emerging Oceanus Folk artists found between \", window_start, \" and \", window_end, \".\")\n}\n\n# ─── 3. COMPUTE EARLY‐CAREER “POPULARITY” ─────────────────────────────────────\nsongs_oceanus_full <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\") %>%\n  mutate(\n    release_year     = suppressWarnings(as.integer(str_extract(release_date, \"\\\\d{4}\"))),\n    written_year     = suppressWarnings(as.integer(str_extract(written_date, \"\\\\d{4}\"))),\n    first_year_song  = pmin(release_year, written_year, na.rm = TRUE),\n    is_notable       = !is.na(notoriety_date)\n  ) %>%\n  select(song_idx = idx, first_year_song, is_notable)\n\nartist_songs <- edges_idx %>%\n  filter(\n    `Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n    from %in% person_first_oceanus$person_idx,\n    to   %in% songs_oceanus_full$song_idx\n  ) %>%\n  select(person_idx = from, song_idx = to) %>%\n  left_join(songs_oceanus_full, by = \"song_idx\") %>%\n  left_join(person_first_oceanus, by = \"person_idx\")\n\nartist_songs_early <- artist_songs %>%\n  filter(\n    first_year_song >= first_oceanus_year,\n    first_year_song <= first_oceanus_year + early_window_years\n  )\n\npopularity_tbl <- artist_songs_early %>%\n  filter(is_notable) %>%\n  count(person_idx, name = \"early_notable_songs\")\n\npopularity_tbl <- person_first_oceanus %>%\n  select(person_idx) %>%\n  left_join(popularity_tbl, by = \"person_idx\") %>%\n  mutate(early_notable_songs = replace_na(early_notable_songs, 0))\n\n# ─── 4. COMPUTE EARLY‐CAREER “INFLUENCE” ─────────────────────────────────────\nnodes_years <- nodes_tbl %>%\n  mutate(\n    release_year   = suppressWarnings(as.integer(str_extract(release_date, \"\\\\d{4}\"))),\n    written_year   = suppressWarnings(as.integer(str_extract(written_date, \"\\\\d{4}\"))),\n    notoriety_year = suppressWarnings(as.integer(str_extract(notoriety_date, \"\\\\d{4}\"))),\n    node_year      = pmin(release_year, written_year, notoriety_year, na.rm = TRUE)\n  ) %>%\n  select(idx, node_year)\n\nartist_infl_edges <- edges_idx %>%\n  filter(\n    `Edge Type` %in% influence_edge_types,\n    (from %in% person_first_oceanus$person_idx) |\n    (to   %in% person_first_oceanus$person_idx)\n  ) %>%\n  left_join(nodes_years, by = c(\"from\" = \"idx\")) %>% rename(year_from = node_year) %>%\n  left_join(nodes_years, by = c(\"to\"   = \"idx\")) %>% rename(year_to   = node_year) %>%\n  mutate(edge_year = pmax(year_from, year_to, na.rm = TRUE))\n\nartist_infl_early <- artist_infl_edges %>%\n  mutate(person_idx = if_else(from %in% person_first_oceanus$person_idx, from, to)) %>%\n  left_join(person_first_oceanus, by = \"person_idx\") %>%\n  filter(\n    edge_year >= first_oceanus_year,\n    edge_year <= first_oceanus_year + early_window_years\n  ) %>%\n  count(person_idx, name = \"early_influence_edges\")\n\ninfluence_tbl <- person_first_oceanus %>%\n  select(person_idx) %>%\n  left_join(artist_infl_early, by = \"person_idx\") %>%\n  mutate(early_influence_edges = replace_na(early_influence_edges, 0))\n\n# ─── 5. COMBINE & RANK EMERGING ARTISTS ───────────────────────────────────────\nemerging_metrics <- person_first_oceanus %>%\n  left_join(popularity_tbl, by = \"person_idx\") %>%\n  left_join(influence_tbl,  by = \"person_idx\") %>%\n  left_join(nodes_tbl %>% select(person_idx = idx, name), by = \"person_idx\") %>%\n  mutate(total_score = early_notable_songs + early_influence_edges) %>%\n  select(person_idx, name, first_oceanus_year,\n         early_notable_songs, early_influence_edges, total_score) %>%\n  arrange(desc(total_score), desc(early_notable_songs))\n\ntop3_emerging <- emerging_metrics %>% slice_head(n = 3)\n\n# ─── 6. RENDER AS DATA TABLE WITH SCROLLING ──────────────────────────────────\nDT::datatable(\n  top3_emerging,\n  extensions = \"Buttons\",\n  options = list(\n    scrollX    = TRUE,\n    pageLength = 5\n  )\n)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-38-1.png)\n:::\n:::\n\n\n\n::: {.callout-note title=\"Most notable songs from emerging artists in Oceanus Folk genre\"}\n-   Orla Seabloom, Beatrice Albright & Daniel O'Connell have the most notable songs (4\\<=) and their debut was between 2025 to 2035.\n-   Let's visualise them against the rest of the artist to have a clearer view on this take.\n:::\n\n## Visualising Notable Oceanus Folk songs based on debut of Artist from 2025 to 2035\n\n-   I will be restricting the artists whose first Oceanus Folk release fell in 2025–2035 and count that as notable songs for more relevance for recent years.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\nlibrary(plotly)\n\n# 1. Load & index nodes and edges\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% \n  mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\n# Build numeric from/to indices for each edge\nid_map    <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from), !is.na(to))\n\n# 2. Extract Oceanus Folk songs and compute 'song_year' + notable flag\noceanus_songs_full <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\") %>%\n  mutate(\n    release_year   = suppressWarnings(as.integer(str_extract(release_date, \"\\\\d{4}\"))),\n    written_year   = suppressWarnings(as.integer(str_extract(written_date, \"\\\\d{4}\"))),\n    song_year      = pmin(release_year, written_year, na.rm = TRUE),\n    is_notable     = !is.na(notoriety_date)\n  ) %>%\n  filter(!is.na(song_year)) %>%\n  select(song_idx = idx, song_year, is_notable)\n\n# 3. Identify all Person indices\nperson_idxs <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  pull(idx)\n\n# 4. Find ComposerOf / PerformerOf edges linking persons → Oceanus Folk songs\nperson_song_edges <- edges_idx %>%\n  filter(\n    `Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n    from %in% person_idxs,\n    to   %in% oceanus_songs_full$song_idx\n  ) %>%\n  select(person_idx = from, song_idx = to)\n\n# 5. Compute each person’s first Oceanus Folk year, then filter to 2028–2040\nperson_first_oceanus <- person_song_edges %>%\n  left_join(oceanus_songs_full, by = \"song_idx\") %>%\n  group_by(person_idx) %>%\n  summarize(\n    first_oceanus_year = min(song_year, na.rm = TRUE),\n    .groups = \"drop\"\n  ) %>%\n  filter(first_oceanus_year >= 2025, first_oceanus_year <= 2035) %>%\n  # Attach PersonName\n  left_join(\n    nodes_tbl %>% select(person_idx = idx, PersonName = name),\n    by = \"person_idx\"\n  )\n\nif (nrow(person_first_oceanus) == 0) {\n  stop(\"No Oceanus Folk persons with first release between 2028 and 2040.\")\n}\n\n# 6. For those emerging persons, find their notable Oceanus Folk songs between 2028–2040\nartist_notable_songs <- edges_idx %>%\n  filter(\n    `Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n    from %in% person_first_oceanus$person_idx,\n    to   %in% oceanus_songs_full$song_idx\n  ) %>%\n  left_join(oceanus_songs_full, by = c(\"to\" = \"song_idx\")) %>%\n  left_join(person_first_oceanus, by = c(\"from\" = \"person_idx\")) %>%\n  # keep only songs that are notable and within 2028–2040\n  filter(\n    is_notable,\n    song_year >= 2025,\n    song_year <= 2035\n  ) %>%\n  select(PersonName, song_year)\n\n# 7. Count notable songs per PersonName per year\nnotable_counts <- artist_notable_songs %>%\n  count(PersonName, year = song_year, name = \"NotableCount\")\n\n# 8. Create a year grid from 2028 to 2040 and person list\nyear_seq    <- tibble(year = 2025:2035)\nperson_list <- person_first_oceanus %>% pull(PersonName) %>% unique()\n\n# Expand to all combinations and fill missing with zero\nall_combos <- expand_grid(PersonName = person_list, year = 2025:2035)\n\nnotable_trends <- all_combos %>%\n  left_join(notable_counts, by = c(\"PersonName\", \"year\")) %>%\n  replace_na(list(NotableCount = 0))\n\n# 9. Static ggplot (for sizing/legend adjustments)\nstatic_plot <- ggplot(notable_trends, aes(x = year, y = NotableCount, color = PersonName, group = PersonName)) +\n  geom_line(position = position_dodge(width = 1.5), size = 1) +\n  geom_point(position = position_dodge(width = 1.5), size = 2) +\n  scale_x_continuous(breaks = seq(2025, 2035, by = 2)) +\n  labs(\n    title    = \"Notable Oceanus Folk Songs by Emerging Artists (2025–2035)\",\n    subtitle = \"Click a legend item to isolate that artist\",\n    x        = \"Year\",\n    y        = \"Number of Notable Songs\",\n    color    = \"Artist\"\n  ) +\n  theme_minimal(base_size = 10) +\n  theme(\n    legend.text   = element_text(size = 8),\n    legend.title  = element_text(size = 9),\n    plot.title    = element_text(size = 12, face = \"bold\"),\n    plot.subtitle = element_text(size = 10),\n    axis.text.x   = element_text(angle = 45, hjust = 1)\n  )\n\n# 10. Convert to interactive Plotly, adjust legend for “toggle others” on click\ninteractive_plot <- ggplotly(static_plot, tooltip = c(\"x\", \"y\", \"colour\")) %>%\n  layout(\n    legend = list(\n      font = list(size = 8),\n      itemclick = \"toggleothers\",    # clicking a legend item isolates that trace\n      itemdoubleclick = \"toggle\"     # double-click brings back all traces\n    )\n  )\n\n# 11. Print the interactive plot\ninteractive_plot\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-39-1.png)\n:::\n:::\n\n\n\n::: {.callout-note title=\"Findings based on Notable Songs\"}\n-   This plot shows that Orla, Beatrice and Daniel indeed have the most notable songs in the \"recent\" time period.\n:::\n\n::: {.callout-tip title=\"Sailor Shift outlier\"}\n-   It's worth to note that Sailor Shift has alot more notable songs overall. But only 1 of it falls under the 2025 - 2035 period.\n\n-   The reason why Sailor Shift isn't considered an **\"rising star\"** is due to the combination of 2 filters.\n\n    1.  Emerging-artist filter (2025 - 2035) - **1st** Oceanus Folk song_year must fall in this window.\n    2.  \"Notable\" + Year - The song must have a non-NA notoriety_date in the period.\n:::\n\n**Orla Seabloom, Beatrice Albright and Daniel O'Connell** are the most promising upcoming Oceanus Folk artists based on popularity in recent years.\n\n## Influences\n\n-   I will plot the influence diagram without splitting the work and influence related edges. This will show a good overview of Orla Seabloom, Beatrice Albright and Daniel O'Connell's connection.\n\n::: panel-tabset\n### Oceanus Folk visNetwork from 2025 - 2035\n\n-   Limiting the hop to 1.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ─── 0. How many hops? ────────────────────────────────────────────────────────\nmax_hops <- 1\n\n# ─── 1. Load & index all nodes and edges ────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# ─── 2. Extract Oceanus Folk songs with their earliest year ────────────────\noceanus_songs_full <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\") %>%\n  mutate(\n    release_year = suppressWarnings(as.integer(str_extract(release_date, \"\\\\d{4}\"))),\n    written_year = suppressWarnings(as.integer(str_extract(written_date, \"\\\\d{4}\"))),\n    song_year    = pmin(release_year, written_year, na.rm = TRUE)\n  ) %>%\n  filter(!is.na(song_year)) %>%\n  select(song_idx = idx, song_year)\n\n# ─── 3. Identify Person→Oceanus Folk edges ─────────────────────────────────\nperson_idxs <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  pull(idx)\n\nperson_song_edges <- edges_idx %>%\n  filter(\n    `Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n    from %in% person_idxs,\n    to   %in% oceanus_songs_full$song_idx\n  )\n\n# ─── 4. Compute each person’s first Oceanus Folk year, then filter to 2025–2035 ─\nperson_first_oceanus <- person_song_edges %>%\n  left_join(oceanus_songs_full, by = c(\"to\" = \"song_idx\")) %>%\n  group_by(from) %>%\n  summarize(first_oceanus_year = min(song_year, na.rm = TRUE), .groups = \"drop\") %>%\n  filter(first_oceanus_year >= 2025, first_oceanus_year <= 2035) %>%\n  rename(person_idx = from)\n\nif (nrow(person_first_oceanus) == 0) {\n  stop(\"No Oceanus Folk artists with first release between 2025 and 2035.\")\n}\n\nfocus_artists <- nodes_tbl %>%\n  filter(idx %in% person_first_oceanus$person_idx, `Node Type` == \"Person\") %>%\n  pull(name)\n\n# ─── 5. Build an undirected igraph of the full graph ────────────────────────\ng_all <- graph_from_data_frame(\n  d        = edges_idx %>% select(from, to),\n  directed = FALSE,\n  vertices = nodes_tbl %>% transmute(name = as.character(idx))\n)\n\n# ─── 6. Compute each focus artist’s 1-hop ego set; then union ─────────────\nego_indices_list <- lapply(person_first_oceanus$person_idx, function(a_idx) {\n  ego(g_all, order = max_hops, nodes = as.character(a_idx), mode = \"all\")[[1]]\n})\nall_ego_numeric <- unique(as.integer(unlist(ego_indices_list)))\n\n# ─── 7. Filter edges to include both influence and work edges among that union ─\nkeep_edge_types <- c(\n  \"InterpolatesFrom\", \"InStyleOf\", \"LyricalReferenceTo\",\n  \"CoverOf\", \"DirectlySamples\",\n  \"ComposerOf\", \"PerformerOf\", \"MemberOf\", \"Released\"\n)\n\ncareer_edges <- edges_idx %>%\n  filter(\n    from %in% all_ego_numeric,\n    to   %in% all_ego_numeric,\n    `Edge Type` %in% keep_edge_types\n  )\n\nif (nrow(career_edges) == 0) {\n  stop(\"No matching edges found within the 1-hop neighborhoods of selected Oceanus Folk artists.\")\n}\n\n# ─── 8. Build the list of all involved nodes ────────────────────────────────\ncareer_node_ids <- unique(c(career_edges$from, career_edges$to))\ncareer_nodes    <- nodes_tbl %>% slice(career_node_ids) %>%\n  mutate(\n    vis_id = row_number(),\n    label  = name,\n    group  = `Node Type`,\n    title  = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`)\n  )\n\n# ─── 9. Remap each career_edge → (from_vis, to_vis) by matching against career_node_ids ─\ncareer_edges <- career_edges %>%\n  mutate(\n    from_vis = match(from, career_node_ids),\n    to_vis   = match(to,   career_node_ids)\n  )\n\n# ─── 10. Construct visNetwork data frames for nodes & edges ─────────────────\nvn_nodes <- career_nodes %>%\n  transmute(\n    id    = vis_id,\n    label = label,\n    group = group,\n    title = title\n  )\n\nvn_edges <- career_edges %>%\n  transmute(\n    from  = from_vis,\n    to    = to_vis,\n    label = `Edge Type`,\n    title = `Edge Type`,\n    color = case_when(\n      label == \"InterpolatesFrom\"   ~ \"#1f78b4\",\n      label == \"InStyleOf\"          ~ \"#e31a1c\",\n      label == \"LyricalReferenceTo\" ~ \"#6a3d9a\",\n      label == \"CoverOf\"            ~ \"#fb9a99\",\n      label == \"DirectlySamples\"    ~ \"#33a02c\",\n      label == \"ComposerOf\"         ~ \"#666666\",\n      label == \"PerformerOf\"        ~ \"#444444\",\n      label == \"MemberOf\"           ~ \"#888888\",\n      label == \"Released\"           ~ \"#AAAAAA\",\n      TRUE                          ~ \"#999999\"\n    )\n  )\n\n# ─── 11. Determine which vis_id correspond to the focus artists (sorted alphabetically) ──\nfocus_vis_ids <- vn_nodes %>%\n  filter(label %in% focus_artists) %>%\n  arrange(label) %>%        # sort by artist name ascending\n  pull(id)\n\n# ─── 12. Render interactive visNetwork with alphabetically sorted dropdown ───\nvisNetwork(vn_nodes, vn_edges, height = \"600px\", width = \"100%\") %>%\n  visNodes(\n    shape = \"dot\",\n    size  = 14,\n    font  = list(color = \"black\", size = 10)\n  ) %>%\n  visEdges(\n    arrows             = \"to\",\n    labelHighlightBold = TRUE,\n    font               = list(color = \"white\", size = 7)\n  ) %>%\n  visOptions(\n    highlightNearest = list(enabled = TRUE, degree = 1),\n    nodesIdSelection = list(\n      enabled   = TRUE,\n      useLabels = TRUE,\n      values    = focus_vis_ids\n    )\n  ) %>%\n  visLegend(useGroups = TRUE, width = 0.1, position = \"right\") %>%\n  visIgraphLayout(layout = \"layout_with_fr\", randomSeed = 1234) %>%\n  visPhysics(enabled = FALSE)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-40-1.png)\n:::\n:::\n\n\n\n### Betweenness Centrality\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ─── PARAMETERS ───────────────────────────────────────────────────────────────\nmax_hops <- 1\nstart_year <- 2025\nend_year   <- 2035\n\n# ─── 1. Load & index all nodes and edges ────────────────────────────────────\nkg_raw    <- fromJSON(\"data/MC1_graph.json\")\nnodes_tbl <- as_tibble(kg_raw$nodes) %>% mutate(idx = row_number())\nlinks_tbl <- as_tibble(kg_raw$links)\n\nid_map <- nodes_tbl %>% select(id, idx)\nedges_idx <- links_tbl %>%\n  left_join(id_map, by = c(\"source\" = \"id\"))  %>% rename(from = idx) %>%\n  left_join(id_map, by = c(\"target\" = \"id\"))  %>% rename(to   = idx) %>%\n  filter(!is.na(from) & !is.na(to))\n\n# ─── 2. Identify all Oceanus Folk songs with computed year ─────────────────\noceanus_songs_full <- nodes_tbl %>%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\") %>%\n  mutate(\n    release_year = suppressWarnings(as.integer(str_extract(release_date, \"\\\\d{4}\"))),\n    written_year = suppressWarnings(as.integer(str_extract(written_date, \"\\\\d{4}\"))),\n    song_year    = pmin(release_year, written_year, na.rm = TRUE)\n  ) %>%\n  filter(!is.na(song_year)) %>%\n  select(song_idx = idx, song_year)\n\n# ─── 3. Find Person→Oceanus Folk edges and determine first-release year ────\nperson_idxs <- nodes_tbl %>%\n  filter(`Node Type` == \"Person\") %>%\n  pull(idx)\n\nperson_song_edges <- edges_idx %>%\n  filter(\n    `Edge Type` %in% c(\"ComposerOf\", \"PerformerOf\"),\n    from %in% person_idxs,\n    to   %in% oceanus_songs_full$song_idx\n  )\n\nperson_first_oceanus <- person_song_edges %>%\n  left_join(oceanus_songs_full, by = c(\"to\" = \"song_idx\")) %>%\n  group_by(from) %>%\n  summarize(first_oceanus_year = min(song_year, na.rm = TRUE), .groups = \"drop\") %>%\n  filter(first_oceanus_year >= start_year, first_oceanus_year <= end_year) %>%\n  rename(person_idx = from)\n\nif (nrow(person_first_oceanus) == 0) {\n  stop(\"No Oceanus Folk artists with first release between \", start_year, \" and \", end_year, \".\")\n}\n\n# ─── 4. Compute each focus artist’s 1-hop ego set; then take the union ─────\ng_all <- graph_from_data_frame(\n  d        = edges_idx %>% select(from, to),\n  directed = FALSE,\n  vertices = nodes_tbl %>% transmute(name = as.character(idx))\n)\n\nego_indices_list <- lapply(person_first_oceanus$person_idx, function(a_idx) {\n  ego(g_all, order = max_hops, nodes = as.character(a_idx), mode = \"all\")[[1]]\n})\nall_ego_numeric <- unique(as.integer(unlist(ego_indices_list)))\n\n# ─── 5. Filter edges to include both influence and work edges among that union ─\nkeep_edge_types <- c(\n  \"InterpolatesFrom\", \"InStyleOf\", \"LyricalReferenceTo\",\n  \"CoverOf\", \"DirectlySamples\",\n  \"ComposerOf\", \"PerformerOf\", \"MemberOf\", \"Released\"\n)\n\ncareer_edges <- edges_idx %>%\n  filter(\n    from %in% all_ego_numeric,\n    to   %in% all_ego_numeric,\n    `Edge Type` %in% keep_edge_types\n  )\n\nif (nrow(career_edges) == 0) {\n  stop(\"No matching edges found within the 1-hop neighborhoods of selected Oceanus Folk artists.\")\n}\n\n# ─── 6. Build the list of all involved nodes ────────────────────────────────\ncareer_node_ids <- unique(c(career_edges$from, career_edges$to))\ncareer_nodes    <- nodes_tbl %>% slice(career_node_ids) %>%\n  mutate(\n    vis_id = row_number(),\n    label  = name,\n    group  = `Node Type`,\n    title  = paste0(\"<b>\", name, \"</b><br>Type: \", `Node Type`)\n  )\n\n# ─── 7. Build an igraph object for this subnetwork ──────────────────────────\n#    We use original idx as the igraph 'name' attribute\nvertices_df <- career_nodes %>%\n  transmute(name = as.character(idx), label = label, group = `Node Type`, title = title)\n\nedges_df <- career_edges %>%\n  transmute(\n    from_name = as.character(from),\n    to_name   = as.character(to),\n    etype     = `Edge Type`\n  )\n\ng_sub <- graph_from_data_frame(\n  d = edges_df %>% select(from = from_name, to = to_name),\n  directed = FALSE,\n  vertices = vertices_df\n)\n\n# ─── 8. Compute betweenness centrality for every vertex ─────────────────────\nbetw_vals <- betweenness(g_sub, v = V(g_sub), directed = FALSE, normalized = TRUE)\n\n# Create a tidy tibble of (label, group, betweenness)\nbetw_tbl <- tibble(\n  node_id      = V(g_sub)$name,\n  label        = V(g_sub)$label,\n  group        = V(g_sub)$group,\n  betweenness  = betw_vals\n) %>%\n  arrange(desc(betweenness))\n\n# ─── 9. Plot top 10 nodes by betweenness ────────────────────────────────────\ntop_n <- 10\nbetw_tbl %>%\n  slice_head(n = top_n) %>%\n  ggplot(aes(x = fct_reorder(label, betweenness), y = betweenness, fill = group)) +\n  geom_col(show.legend = FALSE) +\n  coord_flip() +\n  labs(\n    title = \"Top 10 Nodes by Betweenness Centrality\",\n    x     = \"Node\",\n    y     = \"Betweenness (normalized)\"\n  ) +\n  theme_minimal(base_size = 12)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-docx/unnamed-chunk-41-1.png)\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"Influence Notes\"}\nBased on the plots and betweenness centrality values:\n\n-   Orla Seabloom, Beatrice Albright & Daniel O'Connell appear in the top 10 most critical nodes under Oceanus Folk in the later years (2025 - 2035)\n\n-   We have to count out Sailor Shift and Yang Wan as they might have already been very popular + influential artists in the earlier years before 2025, which led them to having high scores\n:::\n\n## **Summary of part (b)**\n\nBased on the Popularity and Influence plots we can predict based on Oceanus Folks who might be the upcoming rising stars in the next few years.\n\nLooking at the plots, there is significant evidence that show that **1) Orla Seabloom, 2) Beatrice Albright & 3) Daniel O'Connell** are the next upcoming Oceanus Folk stars that debut recently that will likely continue to chart over the next 5 years.\n",
    "supporting": [
      "Take-Home_Ex02_files\\figure-docx"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}